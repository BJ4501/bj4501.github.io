{"pages":[{"title":"","text":"Jmeow's Wonderland Jmeow Furry | Code | GameDesign 这里是杰喵的博客，大部分时间会作为学习笔记的 仓库，有时候也会记录点自己的生活点滴。 其实这里应该放一些自我介绍什么的，但是好像也没什么意义。 就这样吧。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"Android布局相关","text":"LinearLayout vertical 垂直排列 horizontal 水平排列 match_parent 控件的宽度或高度会填满其所在的父控件 wrap_content 控件大小由内容决定 gravity android:gravity 可以不考虑当前布局的方向 android:layout_gravity 需要考虑当前布局的方向 center_horizontal|center_vertical 水平居中，竖直居中 权重布局WeightLayout match_parent 被设置weight值的控件，宽度应为该控件的原宽度+父控件的剩余空间*比例 水平方向的线性布局中：使用weight时，需要将宽度设置为0dp 垂直方向的线性布局中：使用weight时，需要将高度设置为0dp first的宽度：match_parent(原宽度)+(match_parent-(match_parent+match_parent))*1/3设，match_parent为a first的宽度：a+(a-2a)*1/3 = 2/3a first的宽度为父控件2/3，即占父控件的2/3份 second的宽度:a+(a-2a)*2/3 = 1/3a second的宽度为父控件1/3，即占父控件的1/3份 Demo 12345678910111213141516171819202122&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" android:background=\"#00ffff\" tools:context=\"net.bj.talker.talktest.WeightActivity\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"first\" android:layout_weight=\"1\" android:background=\"#00ff00\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"second\" android:layout_weight=\"1\" android:background=\"#0000ff\" /&gt;LinearLayout&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-bu-ju-xiang-guan/"},{"title":"Android RelativeLayout属性","text":"RelativeLayout各个属性 android:layout_above=\"@id/xxx\" --此控件底部的边缘位于设定ID控件的上方 android:layout_below=\"@id/xxx\" --此控件顶部的边缘位于设定ID控件的下方 android:layout_toLeftOf=\"@id/xxx\" --将控件的右边缘和给定ID控件的左边缘对齐 android:layout_toRightOf=\"@id/xxx\" --将控件的左边缘和给定ID控件的右边缘对齐 android:layout_alignLeft=\"@id/xxx\" --将控件的左边缘和给定ID控件的左边缘对齐 android:layout_alignTop=\"@id/xxx\" --将控件的上边缘和给定ID控件的上边缘对齐 android:layout_alignRight=\"@id/xxx\" --将控件的右边缘和给定ID控件的右边缘对齐 android:layout_alignBottom=\"@id/xxx\" --将控件的底边缘和给定ID控件的底边缘对齐 android:layout_alignParentLeft=“true” --将控件的左边缘和父控件的左边缘对齐 android:layout_alignParentTop=“true” --将控件的上边缘和父控件的上边缘对齐 android:layout_alignParentRight=“true” --将控件的右边缘和父控件的右边缘对齐 android:layout_alignParentBottom=“true” --将控件的底边缘和父控件的底边缘对齐 android:layout_centerInParent=“true” --将控件置于父控件的中心位置 android:layout_centerHorizontal=“true” --将控件置于水平方向的中心位置 android:layout_centerVertical=“true” --将控件置于垂直方向的中心位置 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-relativelayout-shu-xing/"},{"title":"安卓面试相关知识-1","text":"Service service和线程的区别和场景 安卓线程（主线程-包括UI控件的绘制和事件响应，工作线程） 一般的线程还可以执行一些耗时的异步操作，一般不要在主线程上做耗时操作，会导致ANR service运行在主线程中，系统进程托管 如何管理service生命周期 生命周期1：service会通过绑定服务，进行service和Activity之间的绑定 生命周期2：直接去开启一个服务 这两种生命周期不同。但是共同点是从OnCreate开始到OnDestory结束 service和IntentService的区别 service不是独立的进程，是依赖于应用程序主线程，在service中进行耗时操作也会产生ANR IntentService中会有工作线程去处理耗时操作，任务执行完成之后IntentService会自动停止 启动服务和绑定服务先后次序问题 Android只会为service创建一个实例对象 序列化：Parcelable和Serializable Binder：多进程间通信依赖Binder service和线程的区别和场景 Thread：程序执行的最小单元，它是分配CPU的基本单位 UI线程：主线程中 工作线程（子线程）：耗时异步操作 为了保证应用响应及时，所以尽量不在主线程做耗时操作 Thread的声明周期 新建：new Thread() 就绪：线程已经启动了，正在等待CPU时间 运行：running 正在执行任务 死亡：dead 线程被其他线程杀死，或执行完毕 阻塞：block 由于某种原因，正在运行线程让出自己的CPU时间，并暂停自己的运行 Thread的致命缺点 无法控制！ Service Service是Android的一种机制，服务是运行在主线程上的 轻量级进程间通信机制，在Liunx层 不可以进行耗时操作 Service的生命周期 onCreate onStart onDestory onBind onUnbind 管理Service生命周期 startSerice 启动之后，只会执行一次onCreate 但是onStartCommand()会启动多次，启动次数是与startService相同 stopService onDestory 如果服务已经被绑定的状态下stopService是无法停止服务的 bindService 绑定Service服务 调用onCreate onBind unbindServce 解绑Service服务 调用onUnbind onDestory Service 和 IntentService 不建议在Service中编写耗时的逻辑和操作，可能会引起ANR IntentService IntentService是继承Service并处理异步请求的类 内部有一个工作线程HandlerThread处理耗时操作 IntentService内部是通过消息的方式发送给HandlerThread的，然后由Handler中的Looper来处理消息。 执行完成之后，会自动停止 onHandleIntent 启动服务&amp;绑定服务 先绑定服务后启动服务 绑定的服务会转变为启动服务状态，当绑定的Activity结束时，服务并不会停止 先启动服务后绑定服务 不会转为绑定服务状态，还是会和Activity绑定。即使Activity解除绑定，服务还是回按照启动服务的生命周期进行 启动服务的优先级比绑定服务高 服务在其托管进程的主线程中运行(UI线程) 序列化：Parcelable和Serializable 序列化：内存中对象–&gt;磁盘 反序列化：磁盘中对象–&gt;内存 实现上 Serializable：实现简单，但是内存开销大 serialVersionUID Parcelable：实现复杂，内存开销小 在内存间传输数据，推荐使用。例如：Activity使用Intent传值（组件之间传输数据） binder应用： AIDL AIDL 进程间通信(IPC)机制 2.AIDL创建 创建AIDL：实体对象，新建AIDL文件，make工程 服务端：新建Service，创建Binder对象，定义方法 客户端：实现serviceConnection，BindService 静态注册&amp;动态注册 广播接收器 BoardcastReceiver 静态注册：在Manifest中 1&lt;receiver&gt;receiver&gt; 动态注册 (在代码中调用Context.registerReceiver) 在onResume调用registerReceiver 在onPause销毁 unregisterReceiver 在onResume注册，onPause注销原因：防止内存泄露 特点 静态：常驻进程中，不受组件生命周期影响(即使应用程序关闭，如果有广播发送，程序也会被系统唤醒) 动态：跟随组件的生命周期变化 应用场景 静态：需要时刻监听广播(计算每隔一段时间的网络访问量) 动态：需要在特定时刻接收广播 广播接收器在接收到广播之后会自动回调onReceive()方法 默认广播接收器运行在UI线程(ANR注意) Webview Webview常见的坑 API16 WebView.addJavascriptInterface 攻击者使用Java反射机制，执行任意Java对象的方法 Webview在布局文件的使用：webview写在其他容器中时 jsbridge：通过JavaScript构建的桥，web-&gt;native webviewClient.onPageFinished -&gt; webChromeClient.onProgressChanged（更推荐） 后台耗电：解决方法，在Activity中onDestory，一定要销毁掉webview Webview硬件加速导致页面渲染问题：可能会出现页面加载白块，同时界面闪烁(解决方法，暂时关闭硬件加速) 关于Webview的内存泄露问题(webview可能会一直持有Activity引用，不能回收)解决办法 独立进程，简单暴力，不过可能涉及到进程间通信 动态添加WebView，对传入WebView中使用的Context使用弱引用，动态添加WebView意思在布局创建个ViewGroup用来放置WebView，Activity创建时add进来，在Activity停止时remove掉 异步消息处理 Handler Android SDK 提供给开发者方便进行异步消息处理的类 Handler Looper：轮询操作 MessageQueue消息队列：FIFO原则的消息 Handler：会取出当前线程的Looper，Looper从消息队列中取出消息，交给Handler处理 -&gt; handleMessage() Handler发送消息，处理解决消息 总结： Looper类主要是为每个线程开启的单独的消息循环(ThreadLocal) Handler是Looper的一个接口 在非主线程中无法直接new Handler() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/an-zhuo-mian-shi-xiang-guan-zhi-shi-1/"},{"title":"Android自定义Loading提示框","text":"工作需要一个自定义的Loading提示框，那么比起从网络上找第三方库修改，从零做一个Loading更能学到更多的知识，那么我们开始吧。 制作一个旋转的Loading控件 首先需要自定义View来承载动画 创建LoadingView继承自View 初始化画笔和图片资源 1234567private void init() {&nbsp;&nbsp;&nbsp; paint = new Paint(); //画笔 抗锯齿 paint.setFlags(Paint.ANTI_ALIAS_FLAG); //图片资源 loadingPic = decodeResource(getResources(), R.drawable.ic_loading);} 在onMeasure中，获取图片的宽度和高度 由于我们是要对控件进行旋转，所以需要取出旋转的最大直径作为控件的宽高，防止旋转中，图案被遮挡。 1234567891011@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); //获取需要旋转的图片宽高 picWidth = loadingPic.getWidth(); picHeight = loadingPic.getHeight(); //选择直角三角形的第三边，作为直径，作为控件的宽高(因需要旋转) //a^2 + b^2 = c^2 max = (int) Math.sqrt(picWidth * picWidth + picHeight * picHeight); setMeasuredDimension(max, max);} 在onDraw中，对图案进行绘制 12345678910@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); //移动画布中心至图片中心点 canvas.translate(max / 2, max / 2); //图片旋转 canvas.rotate(rate); //画出图片 canvas.drawBitmap(loadingPic, -(picWidth / 2), -(picHeight / 2), paint);} 至此，我们已经把对应的图片绘制到控件上了，一切都还比较常规，没有什么难度，接下来要处理的是动画部分。 首先使用ValueAnimator来做一个将沙漏旋转180度的动画。 1234567891011121314//开始动画public void startAnimate() { animator = ValueAnimator.ofFloat(0, 180); animator.setDuration(650); //设置动画时长 animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { rate = (float) animation.getAnimatedValue(); invalidate(); } }); animator.start();} Loading动画是一个可循环的沙漏，也就是说，只要Loading界面没有关闭，需要一直循环下去。这部分在网络搜索了很久，但是一直没有找到合适的办法。 方法1 - TimerTask + Handler 第一次的尝试，使用TimerTask + Handler进行动画，间隔时间进行动画，这里面要注意一点，在TimerTask的run方法执行UI操作，会弹出异常，因为Android只允许在UI线程进行UI操作。所以需要Handler。 12345678910public void startAnimate() { Timer timer = new Timer(); TimerTask timerTask = new TimerTask() { @Override public void run() { rotate(); } }; timer.schedule(timerTask, 100, 750);} 这种方法虽然可以实现，但是十分的麻烦。所以换了一种思路。从ValueAnimator下手 方法2 - ValueAnimator.INFINITE ValueAnimator中有一个方法setRepeatCount，可以将动画循环执行，经过测试，确实有效，但是，沙漏每旋转一次，中间都需要间隔停止一下，但是这个函数，并不可以设置每次动画循环的间隔。所以我们继续想办法。 1animator.setRepeatCount(ValueAnimator.INFINITE); 方法3 - onAnimationEnd 经查阅资料，发现ValueAnimator可以添加监听，也就是addListener,在监听中，可以对动画的起止等操作进行监听，onAnimationEnd则是在动画执行结束时的监听。那么我们是不是可以，在动画结束之后，设置一个启示延迟，然后再执行动画，下一次动画结束时，仍然会触发这个监听，那么不就可以实现动画的循环了么。setStartDelay方法，可以设置ValueAnimator动画延迟多久开始。 123456789101112131415161718192021//开始动画public void startAnimate() { animator = ValueAnimator.ofFloat(0, 180); animator.setDuration(650); //设置动画时长 animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { rate = (float) animation.getAnimatedValue(); invalidate(); } }); animator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { animator.setStartDelay(300); animator.start(); } }); animator.start();} 最后测试发现，动画可以循环执行，也达到了我所预期的效果 方法4 - AnticipateInterpolator 其实方法3已经是一个很优秀的解法了，在方法3测试的时候，使用的是LinearInterpolator的动画效果。但是经过测试，发现AnticipateInterpolator的动画效果更加的有趣。 AnticipateInterpolator是先回拉一下再进行正常动画轨迹，类似于投掷的动画效果，在旋转中也比较酷炫。但是由于动画变成了一组，也就是说，需要先0-180度旋转，在进行180-360度旋转，那么如何实现一组动画的实现和循环播放呢。 这个时候，就用到了AnimatorSet，它可以对一组ValueAnimator动画进行顺序或特殊需求的播放。但是AnimatorSet,不支持动画的循环播放，那怎么办呢，有着上一个监听器的经验，在AnimatorSet中，我们也发现了监听器的功能，那么就很简单了，在监听动画组播放结束之后，重新执行动画播放即可。 12345678910111213141516171819202122232425262728293031323334353637//一个带动感的动画public void startFastAnimate() { ValueAnimator animatorA = ValueAnimator.ofFloat(0, 180); animatorA.setDuration(750); animatorA.setStartDelay(200); animatorA.setInterpolator(new AnticipateInterpolator()); animatorA.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { rate = (float) animation.getAnimatedValue(); invalidate(); } }); ValueAnimator animatorB = ValueAnimator.ofFloat(180, 360); animatorB.setDuration(750); animatorB.setStartDelay(200); animatorB.setInterpolator(new AnticipateInterpolator()); animatorB.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { rate = (float) animation.getAnimatedValue(); invalidate(); } }); //设置动画链 final AnimatorSet set = new AnimatorSet(); set.playSequentially(animatorA, animatorB); set.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { set.start(); } }); set.start();} 制作Loading载体Dialog 现在，我们就可以播放这个带动感的动画了。但是工作就完成了么，并不是，这只是个View，它的载体，也就是Dialog，需要设置一下。 首先创建一个布局文件，用于放置Loading界面的布局样式 12345678910111213141516&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/widget_loading_background\"&gt; &lt;com.dwzq.market.widget.loading.KLoadingView android:id=\"@+id/k_loading\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"40dp\" android:layout_marginTop=\"10dp\" android:layout_marginRight=\"40dp\" android:layout_marginBottom=\"10dp\" android:padding=\"5dp\" /&gt;FrameLayout&gt; 浅灰色背景样式 1234567&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;corners android:radius=\"6dp\" /&gt; &lt;solid android:color=\"#66091018\" /&gt;shape&gt; 设置Dialog的主题Style 123456789101112131415&lt;style name=\"loading_dialog\" parent=\"android:style/Theme.Dialog\"&gt; &lt;item name=\"android:windowFrame\"&gt;@nullitem&gt; &lt;item name=\"android:windowNoTitle\"&gt;trueitem&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparentitem&gt; &lt;item name=\"android:windowIsFloating\"&gt;trueitem&gt; &lt;item name=\"android:backgroundDimEnabled\"&gt;trueitem&gt; &lt;item name=\"android:windowContentOverlay\"&gt;@nullitem&gt;style&gt; 之后就可以通过Dialog来对该Loading界面进行显示了，期间可以进行一些设置，比如，不可点击空白区域取消，设置背景不变暗，设置Loading界面半透明等操作。 123456789101112131415161718192021public static void showLoading(Context context) { Dialog dialog = new Dialog(context, R.style.loading_dialog); View view = LayoutInflater.from(context).inflate(R.layout.widget_k_loading, null); FrameLayout layout = view.findViewById(R.id.root_view); dialog.setContentView(layout); //设置外边空白区域不可点击 dialog.setCanceledOnTouchOutside(false); Window window = dialog.getWindow(); if (window != null){ //设置背景透明 window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); //设置Loading外界面不变暗 WindowManager.LayoutParams lp = window.getAttributes(); lp.dimAmount =0f; window.setAttributes(lp); } KLoadingView view = dialog.findViewById(R.id.k_loading); //开始动画旋转 view.startAnimate(); dialog.show();} 至此，我们就完成了简单的自定义Loading的实现。可以用在项目中了，收工！ 一些Debug的补充 第一版设置Dialog的代码是这样的： 123Dialog dialog = new Dialog(context);dialog.setContentView(R.layout.widget_k_loading);//省略设置逻辑 当时的测试机是Android 6和Android 9，并没有任何问题。但是在兼容性检查中，发现，在Android5.0上，Dialog的位置并非居中，而是靠左或靠右。初步判断是兼容性的问题，但是问题出现在哪里了呢？ 百思不得解之后，我看了一下其他开源Loading库，对于Dialog部分的处理，发现了不同。 1234Dialog dialog = new Dialog(context, R.style.loading_dialog);View view = LayoutInflater.from(context).inflate(R.layout.widget_k_loading, null);FrameLayout layout = view.findViewById(R.id.root_view);dialog.setContentView(layout); 首先是在设置Dialog时，使用了带有Style的重载方法。 1public Dialog(@NonNull Context context, @StyleRes int themeResId) themeResId的注释描述为\"a style resource describing the theme to use for the window\"，也就是描述窗口的主题资源。因为Dialog也是一个window，具体主题参数和解释见正文。 第二个是，setContentView，不同于直接给定一个layoutRes，这里传递了一个View和LayoutParams 1public void setContentView(@NonNull View view, @Nullable ViewGroup.LayoutParams params) 然而为什么会导致这种情况？在5.0的机器上，当注释掉setBackgroundDrawable时，发现了问题所在，实际上包裹LoadingView外层的布局出现了问题，变成了一个长条形的布局。 为了解释这个问题，需要依次查看不同部分的源码，看一下，到底有什么不同。 首先看一下setContentView，这个方法提供了三种重载。 123public void setContentView(@LayoutRes int layoutResID)public void setContentView(@NonNull View view)public void setContentView(@NonNull View view, @Nullable ViewGroup.LayoutParams params) 方法1与23区别比较大，2就是带new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)默认值的3。 12345//来自PhoneWindow.java@Overridepublic void setContentView(View view) { setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));} 这也回答了一个问题，使用setContentView(View)的方式时，无论layout中根容器的宽高是什么，都按照WRAP_CONTENT的方式。而在setContentView(int)中，用户设置的布局，是会被添加到mContentParent中，而mContentParent是由generateLayout()生成的。在这种方式下可以直接通过在layout的根容器中指定宽、高来设置布局的尺寸。但是使用MATCH_PARENT，并不会产生效果。 但是这并不是导致Dialog显示偏移的原因。那来看一下new Dialog时添加的theme，是不是由于这个原因导致的。 查看Dialog构造器部分的代码，发现在没有给定themeId的时候，会使用默认的R.attr.dialogTheme Android Dialog 部分源码 12345678910Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { if (createContextThemeWrapper) { if (themeResId == ResourceId.ID_NULL) { final TypedValue outValue = new TypedValue(); context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, true); themeResId = outValue.resourceId; } mContext = new ContextThemeWrapper(context, themeResId); }} 那么来看一下默认的theme实现是什么样的，或许就可以解释为什么在不同sdk版本下显示存在差异了。文件位置在android-sdk\\platforms\\android-&lt;版本号&gt;\\data\\res\\values\\themes.xml中，但是观察并没有发现差异。 在只继承系统Theme的情况下，5.0和9.0的表现是不同的，5.0是一个长条形的框，而9.0的尺寸是和LoadingView的尺寸相同的。 12&lt;style name=\"loading_dialog\" parent=\"android:style/Theme.Dialog\"&gt;style&gt; 暂时没有更好的办法研究问题出现在哪里了，不过问题目前原因是清晰了，就是因为没有设置Dialog的Theme，与setContentView使用的参数无关。至于不同版本真正产生这个区别的原因，先记录下，等待一个答案的机会。 参考 https://www.cnblogs.com/chorm590/p/6854531.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-zi-ding-yi-loading-ti-shi-kuang/"},{"title":"Android 自定义CollapsingToolbarLayout动效","text":"面对开发中遇到的需求，怎么办呢？研究呗！ 关联控件 CoordinatorLayout AppBarLayout CollapsingToolbarLayout RecyclerView SwipeRefreshLayout 下面放出全部布局，然后逐一讲解内容实现。 首先看一下完成后的效果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.CoordinatorLayout android:id=\"@+id/coo_root\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/app_bar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"#177FFF\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=\"match_parent\" android:layout_height=\"180dp\" android:minHeight=\"74dp\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed|enterAlwaysCollapsed\" app:statusBarScrim=\"@android:color/transparent\"&gt; &lt;ImageView android:id=\"@+id/iv_bg\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:scaleType=\"fitXY\" android:src=\"@drawable/ic_bg_logo\" app:layout_collapseMode=\"parallax\" app:layout_collapseParallaxMultiplier=\"0.9\" /&gt; &lt;com.dwzq.market.view.trade.reversebond.ExtendToolbar android:id=\"@+id/tv_title\" android:layout_width=\"match_parent\" android:layout_height=\"74dp\" app:contentInsetStart=\"0dp\" app:layout_collapseMode=\"pin\" /&gt; android.support.design.widget.CollapsingToolbarLayout&gt; android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_hold_list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingLeft=\"10dp\" android:paddingRight=\"10dp\" app:behavior_overlapTop=\"50dp\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; android.support.design.widget.CoordinatorLayout&gt; &lt;TextView android:id=\"@+id/tv_total_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"30dp\" android:layout_marginTop=\"49dp\" android:text=\"总数值\" android:textColor=\"@color/p_white\" android:textSize=\"14sp\" /&gt; &lt;com.dwzq.market.widget.textview.DigitsFontTextView2 android:id=\"@+id/tv_total_value\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"30dp\" android:layout_marginTop=\"79dp\" android:text=\"90,899.63\" android:textColor=\"@color/p_white\" android:textSize=\"30sp\" /&gt;FrameLayout&gt; 折叠部分 首先折叠动效，在MaterialDesign中有类似的实现，就是CollapsingToolbarLayout。 CollapsingToolbarLayout需要被CoordinatorLayout,AppBarLayout包裹后才可正常使用。 这里面需要注意几个参数： app:layout_scrollFlags 这个参数用来确定折叠Toolbar的折叠方式 scroll 当前页面可以滚动 exitUntilCollapsed 滚动结束后，仍然显示Toolbar(折叠的) enterAlwaysCollapsed 需要配合android:minHeight使用，表示最小折叠高度(当需要折叠保留的部分大于Toolbar的高度情况) android:minHeight 配合exitUntilCollapsed使用，保持最小高度 当内容控件(后面会讲)存在高度偏移时app:behavior_overlapTop，此参数需要设置，默认可设置为?actionBarSize 当CollapsingToolbarLayout配合RecyclerView使用的时候，可能会存在最后一项显示不完整，可设置为?actionBarSize来解决 app:statusBarScrim 当进行全面屏适配时，折叠后状态栏的颜色设置，可设置为@android:color/transparent 背景图片部分 由于需求中，Toolbar上存在背景图片，并且需要在折叠中依旧浮动在Toolbar上，设置如下。 在CollapsingToolbarLayout中，第一个子布局放置ImageView做为背景，同时根据需求调整gravity等属性。 需要特殊提示的属性： android:scaleType 这里面有很多选项，具体需要查阅文档。 fitXY 可以不用保持图像的宽高比，从控件的左上角分别对图片的宽和高进行缩放 centerCrop 保持图像的宽高比，进行缩放图像 app:layout_collapseMode=\"parallax\" 视差模式，在折叠的时候会有个视差折叠的效果 app:layout_collapseParallaxMultiplier=\"0.9\" 设置视差范围,0-1越大视差越大 Toolbar部分 由于需求中的Toolbar比常规工具栏多出一部分，用于放置缩小折叠后的值。那么我们自定义一个Toolbar。 使用时需要注意的参数 app:contentInsetStart=\"0dp\" 在自定义Toolbar时，有时会出现左侧有一段空白无法使用，这时候需要进行设置重置空白。 app:layout_collapseMode=\"pin\" 固定模式，收缩到最后固定在顶端。 布局文件 1234567891011121314151617181920212223242526272829&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"74dp\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/fl_value_bar\" android:layout_alignParentTop=\"true\" android:layout_marginLeft=\"20dp\" android:src=\"@drawable/hq_white_back\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/fl_value_bar\" android:layout_alignParentTop=\"true\" android:layout_centerHorizontal=\"true\" android:gravity=\"center_vertical\" android:text=\"标题栏文字\" android:textColor=\"@color/p_white\" android:textSize=\"18sp\" /&gt; &lt;FrameLayout android:id=\"@+id/fl_value_bar\" android:layout_width=\"match_parent\" android:layout_height=\"30dp\" android:layout_alignParentBottom=\"true\" /&gt;RelativeLayout&gt; 自定义Toolbar类文件 12345678910111213141516171819202122public class ExtendToolbar extends Toolbar { public ExtendToolbar(Context context) { this(context, null); } public ExtendToolbar(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public ExtendToolbar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } private void init() { LayoutInflater mInflater = LayoutInflater.from(getContext()); View mView = mInflater.inflate(R.layout.toolbar_reverse_bond, null); LayoutParams lp = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.NO_GRAVITY); addView(mView, lp); }} RecyclerView 数据列表部分 在AppBarLayout外，CoordinatorLayout内，放置需要显示的内容，此处可以为NestedScrollView，RecyclerView，但是不推荐使用ScrollView，存在BUG。 当CollapsingToolbarLayout配合RecyclerView使用的时候，可能会存在最后一项显示不完整，可设置CollapsingToolbarLayout属性android:minHeight=\"?actionBarSize\"来解决。 需要介绍的参数： app:behavior_overlapTop=\"50dp\" 当数据列表需要向上偏移进入CollapsingToolbar部分时，可以设置此参数，向上偏移。 app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" 一定需要添加此参数，表示该控件与CollapsingToolbar通过behavior绑定。 Toolbar 展示数据部分 最开始考虑是用behavior来操作控件滑动，但是behavior因为需要依附在Toolbar控件上,通过app:layout_anchor，app:layout_anchorGravity来操作位置，但是难以做到我需要的效果。 那么考虑使用FrameLayout + TextView将控件浮在布局上方，监听Toolbar移动位置，从而改变TextView的大小和位置。 首先需要取得控件在屏幕中的位置，由于控件的位置需要Measure,Layout之后才能获得，那么我们创建一个监听树来监听控件加载完毕的回调。 123456789101112final ViewTreeObserver viewTreeObserver = getActivity().getWindow().getDecorView().getViewTreeObserver();viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { oX = mBinding.tvTotalValue.getLeft(); oY = mBinding.tvTotalValue.getTop(); // 移除GlobalLayoutListener监听 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) { getActivity().getWindow().getDecorView().getViewTreeObserver().removeOnGlobalLayoutListener(this); } }}); 此时我们就获得了控件距离左侧和上方的位置，之后可以根据折叠后的位置、滑动距离、最大滑动距离，来计算出偏移比例，从而展示出动画效果。 1234567891011121314151617181920appBar.addOnOffsetChangedListener((appBarLayout, verticalOffset) -&gt; { int totalScrollRange = appBarLayout.getTotalScrollRange(); int absOffset = Math.abs(verticalOffset); float percent = (float) absOffset / (float) totalScrollRange; //值 int targetX = DisplayUtils.dp2px(96); int targetY = DisplayUtils.dp2px(51); //名称 int targetNameX = DisplayUtils.dp2px(20); if (oX != 0 || oY != 0) { //总市值 标题 mBinding.tvTotalName.setX(oX - (oX - (float) targetNameX) * percent); //总市值 值 mBinding.tvTotalValue.setX(oX + ((float) targetX - oX) * percent); mBinding.tvTotalValue.setY(oY - (oY - (float) targetY) * percent); mBinding.tvTotalValue.setTextSize(TypedValue.COMPLEX_UNIT_SP, 30f - 14f * percent); }}); 完成以上操作后，就可以实现该动画效果了。此时还可以进行一些扩展功能。比如下拉刷新，全屏模式适配。 扩展：下拉刷新 使用原生方案实现下拉刷新，在布局的根部，使用SwipeRefreshLayout包裹全部布局 1234&lt;android.support.v4.widget.SwipeRefreshLayout android:id=\"@+id/refresh_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 由于监听的是下拉时的事件，那么当Toolbar折叠之后的下拉也会被监听到，这并非我所需要的效果，此时需要在addOnOffsetChangedListener中进行一点设置即可。 123456//当Toolbar完全展开之后，才可使用下拉刷新if (verticalOffset &gt;= 0){ refreshLayout.setEnabled(true);}else { refreshLayout.setEnabled(false);} 扩展：全屏适配的一些提示点 fitSystemWindow 针对状态栏适配 根布局调整padding CollapsingToolbarLayout设置状态栏折叠时颜色 app:statusBarScrim=\"@android:color/transparent\" document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-zi-ding-yi-collapsingtoolbarlayout-dong-xiao/"},{"title":"Android应用前后台状态判断","text":"开发中遇到了一个需求，如果应用在非前台的状态超过一定时间，就需要用户重新去登录。如果用户不进行登录，就回到主页。这种类似的需求我在银行类App中见到过。技术点就是如何判断App当前的状态。 但是这里面状态有很多，并不只是前后台。还有App在前台，但是用户锁屏放置的情况，这种情况，也是需要算作用户未使用App的，所以需要判断的状态如下。 应用状态： 从后台切换到前台 从前台切换到后台 用户锁屏 用户解锁手机 总结出需要判断的内容之后，可以开始根据不同状态编写代码了。 判断前后台切换 首先使用ActivityLifecycleCallbacks接口来接收每一个Activity生命周期的回调，因为我们不知道用户会在哪个Activity中切换App状态，所以需要这个回调来统一处理。 这里解释两个回调方法： onActivityResumed 这里是当App到onResume时统一回调，当应用从后台返回前台时候也会走这个方法。 onActivityStopped 这里是当App到onStop时统一回调，当应用从前台进入时候也会走这个方法。！！注意：这个方法不一定会执行(比如切换最近使用APP列表时)，所以需要配合onTrimMemory一起使用。 onTrimMemory是个很神奇的方法，他实际上是App关于内存优化的一个回调。用于让应用程序在不同的状态下进行内存释放，从而避免被系统杀掉进程。本来与前后台切换并没有什么关系，但是当阅读文档时，发现他在这种状态下是会被回调的： TRIM_MEMORY_UI_HIDDEN 它表示应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键导致应用的UI界面不可见．这时候应该释放一些资源。 那么我们可以通过这个状态来判断用户是否切换到后台，与onStop方法配合使用。 补充：TRIM_MEMORY_BACKGROUND也是应用进入后台的回调，不同的手机厂商可能会使用这两个不同的Flag。最好都进行一下判断。 需要用于判断的回调都准备好了，下面来准备一下需要的常量和变量。 12345678910111213141516//APP状态常量//正常状态public static final int STATE_NORMAL = 0;//从后台回到前台或从锁屏状态返回public static final int STATE_BACK_TO_FRONT = 1;//从前台进入后台或进入锁屏状态public static final int STATE_FRONT_TO_BACK = 2;//App状态public static int sAppState = STATE_NORMAL;//标记程序是否进入后台(onStop回调)private boolean isBackFlag = false;//标记程序是否已进入后台(依据onTrimMemory回调)private boolean background = false;//记录从前台进入后台的时间private static long frontToBackTime; 常量准备好后，现在开始编写判断部分的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//在onCreate中注册此部分registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() { //便于观察，这里删去了暂时不需要的方法 @Override public void onActivityResumed(Activity activity) { if (isBackFlag || background) { //执行到这里说明App是从后台返回的 //状态从后台切换为前台 isBackFlag = false; background = false; sAppState = STATE_BACK_TO_FRONT; //TODO：在这里可以处理App从后台返回的逻辑 //通过frontToBackTime与现在时间的计算，判断用户是否超时 } else { //否则是默认状态 sAppState = STATE_NORMAL; } } @Override public void onActivityStopped(Activity activity) { //判断当前activity是否处于前台 if (!DeviceUtils.isCurAppTop(activity)) { //从前台进入后台 sAppState = STATE_FRONT_TO_BACK; //记录从前台进入后台的时间 frontToBackTime = System.currentTimeMillis(); isBackFlag = true; } }});@Overridepublic void onTrimMemory(int level) { super.onTrimMemory(level); // TRIM_MEMORY_UI_HIDDEN是UI不可见的回调, 通常程序进入后台后都会触发此回调,大部分手机多是回调这个参数 // TRIM_MEMORY_BACKGROUND也是程序进入后台的回调, 不同厂商不太一样, 魅族手机就是回调这个参数 if (level == Application.TRIM_MEMORY_UI_HIDDEN || level == TRIM_MEMORY_BACKGROUND) { background = true; //TRIM_MEMORY_COMPLETE表示内存已经很低，系统可能会杀掉我们的应用 } else if (level == Application.TRIM_MEMORY_COMPLETE) { background = !DeviceUtils.isCurAppTop(this); } if (background) { //记录时间 frontToBackTime = System.currentTimeMillis(); sAppState = STATE_FRONT_TO_BACK; } else { sAppState = STATE_NORMAL; }} isCurAppTop是用来判断程序是否是前台进程的工具类，代码如下： 1234567891011121314151617181920212223/** * 判断当前程序是否前台进程 * * @param context * @return */public static boolean isCurAppTop(Context context) { if (context == null) { return false; } String curPackageName = context.getPackageName(); ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List list = am.getRunningTasks(1); if (list != null &amp;&amp; list.size() &gt; 0) { ActivityManager.RunningTaskInfo info = list.get(0); String topPackageName = info.topActivity.getPackageName(); String basePackageName = info.baseActivity.getPackageName(); if (topPackageName.equals(curPackageName) &amp;&amp; basePackageName.equals(curPackageName)) { return true; } } return false;} 判断用户是否进行锁屏解锁 上面的判断方法虽然已经很完整了，但是当用户将App放置前台并锁屏之后，不会触发上面的流程，那么需要对用户锁屏与解锁的状态进行判断了。 这时候我们需要在onCreate注册一个广播接收器，来接收系统锁屏开屏的广播。 这里简单介绍一下相关的三个状态： Intent.ACTION_SCREEN_ON 用户点亮屏幕 Intent.ACTION_SCREEN_OFF 用户锁屏操作 Intent.ACTION_USER_PRESENT 用户解锁屏幕，这时可以看到App了 123456789101112131415161718192021222324252627282930private class ScreenBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (Intent.ACTION_SCREEN_ON.equals(action)) { // 开屏 } else if (Intent.ACTION_SCREEN_OFF.equals(action)) { // 锁屏 if (sAppState != STATE_FRONT_TO_BACK){ //当应用处于后台时，仍会收到广播。所以在后台时，注意不要刷新从前台进入后台的时间。 isBackFlag = true; sAppState = STATE_FRONT_TO_BACK; frontToBackTime = System.currentTimeMillis(); } } else if (Intent.ACTION_USER_PRESENT.equals(action)) { // 解锁 // TODO：在这里可以判断是否超时，从锁屏回到App的状态处理 } }}//在onCreate中注册广播接收器private void startScreenBroadcastReceiver() { ScreenBroadcastReceiver mScreenReceiver = new ScreenBroadcastReceiver(); IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_SCREEN_ON); filter.addAction(Intent.ACTION_SCREEN_OFF); filter.addAction(Intent.ACTION_USER_PRESENT); this.registerReceiver(mScreenReceiver, filter);} 用户如果不进行登录，返回主页 在App类中，创建管理Activity栈的对象。这里面需要一个工具类。ApplicationActivitiesQueue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import android.app.Activity;import java.util.Stack;/** * 管理 Activity 的 视图栈 * From: https://www.jianshu.com/p/7adf0890e6b9 */public class ApplicationActivitiesQueue { private ApplicationActivitiesQueue() { } private static ApplicationActivitiesQueue queue = new ApplicationActivitiesQueue(); public static ApplicationActivitiesQueue ShareActivityQueue() { return queue; } private Stack activityStack = new Stack(); /** * 获取当前的activity，不做任何操作 */ public Activity currentActivity() { return activityStack.lastElement(); } /** * 只有这俩方法 操作 activityStack不能手动调用（都是自动添加删除的） * addActivity 添加Activity到堆栈 * popCurrentActivity 结束当前Activity * currentActivity */ public void addActivity(Activity activity) { activityStack.push(activity); } public void popCurrentActivity(Activity activity) { activityStack.remove(activity); } /** * 下面的这些方法都是辅助方法 (注意防止当前activity结束当前的导致crash) * 获取当前Activity（堆栈中最后一个压入的） */ // 结束指定的Activity public void finishOneActivity(Activity activity) { if (activity != null) { if (!activity.isFinishing()) { activity.finish(); } } } // 结束指定类名的Activity public void finishOneActivity(Class cls) { for (Activity activity : activityStack) { if (!activity.getClass().equals(cls)) continue; finishOneActivity(activity); return; } } /** * 结束至指定类名Activity(不包括该类名) */ public void finishToActiovity(Class cls) { while (!activityStack.lastElement().getClass().equals(cls)) { activityStack.pop().finish(); if (activityStack.size() == 0) return; } } /** * 结束除指定类名的所有Activity */ public void finishExcludeActivityAllActivity(Class cls) { for (Activity activity : activityStack) { if (activity == null) continue; if (activity.getClass().equals(cls)) continue; finishOneActivity(activity); } } /** * 结束所有Activity */ public void finishAllActivity() { for (Activity activity : activityStack) { if (activity == null) continue; finishOneActivity(activity); } }} 使用方法： 在registerActivityLifecycleCallbacks中的onActivityCreated和onActivityDestroyed将当前Activity添加入视图栈中，之后按需调用视图栈的方法即可。 12345678910111213//Activity队列private ApplicationActivitiesQueue activitiesQueue = ApplicationActivitiesQueue.ShareActivityQueue();registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() { @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) { activitiesQueue.addActivity(activity);//创建 } @Override public void onActivityDestroyed(Activity activity) { activitiesQueue.popCurrentActivity(activity);//退出 }}); 参考 https://www.jianshu.com/p/38ca64901687 https://www.jianshu.com/p/7adf0890e6b9 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-ying-yong-qian-hou-tai-zhuang-tai-pan-duan/"},{"title":"解决Dagger2+DataBinding编译错误提示问题","text":"项目中使用了Dragger2+DataBinding这两个基于Annotation的库，这种库依赖于编译期生成代码来使用。但是他们之间会相互影响，一但一个出错了，会导致Annotation编译时中断。这时Java部分编译检查就会爆出大量的错误，错误原因基本都是DataBinding和Dragger编译期生成的中间类无法找到。这时由于默认编译器只会显示100条错误信息，就会导致我们无法定位到真正的错误位置。 那么如何解决这个问题呢，通过对build.gradle配置文件的修改，使其可以显示超过100条错误信息，这时候我们就可以看到代码真正出现问题的地方了。 具体操作如下： 在项目根目录的build.gradle文件中，在allprojects下添加如下代码。这里填写的是5000，也就是说可以最多显示5000条错误信息，这里可以按照真正的需求来修改。（由于项目非常大，我这里最终提示了2000条错误信息） 12345afterEvaluate { tasks.withType(JavaCompile.class) { options.compilerArgs &lt;&lt; \"-Xmaxerrs\" &lt;&lt; \"5000\" }} 这样就可以定位到真正的问题了，如果错误信息庞大，可以对错误信息进行筛选即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/jie-jue-dagger2-databinding-bian-yi-cuo-wu-ti-shi-wen-ti/"},{"title":"Android AES加解密","text":"项目需要对特定数据进行加密，看了一下网上的很多实现，在不同版本的安卓上需要做一些特殊处理。那么我想试着编写一个通用性比较强，不需要对版本进行适配的AES加解密库。 这个库还可以将AES的密文进行Base64编码之后进行传输，算是功能上的补充。 AES 加密 生成加解密Key 使用SecretKeySpec来将给定数组生成对应的key，由于这里是AES加密，所以algorithm为\"AES\" 1SecretKeySpec keySpec = new SecretKeySpec(key, algorithm); 使用Cipher进行加密 Cipher是javax.crypto中的类，他可以提供加解密的功能。使用getInstance方法来构建Cipher对象，并提供转换(加解密)模式。 这里我使用的是AES/ECB/PKCS5Padding模式，这里可以简单的说一下这几个参数的含义。 transformation使用分隔符分割的三个参数分别为：算法/模式/填充，如果找不到对应的方法，会抛出NoSuchAlgorithmException异常。 首先说算法部分，常用的算法有： AES - Advanced Encryption Standard 高级数据加密标准 DES - Data Encryption Standard 数据加密标准 3DES - Triple DES、DESede 进行了三重DES加密的算法 第二部分是，分组密码的工作模式，常用的模式有： ECB - 电子密码本，每次加密均产生独立的密文分组，并且对其他的密文分组不会产生影响，也就是相同的明文加密后产生相同的密文 CBC - 密文链接，明文加密前需要先和前面的密文进行异或运算，也就是相同的明文加密后产生不同的密文 第三部分，分组密码的填充模式： NoPadding - 不进行填充 ZeroPadding - 数据长度不对齐时使用0填充，否则不填充 PKCS5Padding - PKCS7Padding的子集，块大小固定为8字节 PKCS7Padding - 假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n，如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小 12345Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");//加密模式cipher.init(Cipher.ENCRYPT_MODE, keySpec);//按单部分操作加密或解密数据return cipher.doFinal(data); 使用Cipher进行解密 解密方式与加密方式很相似，在init方法中使用的是Cipher.DECRYPT_MODE，也就是解密模式。由于此时解密完毕的是原文的字节数组，所以需要按照编码格式转换为String。 charset中填入编码时使用的字符集，这里是UTF-8。 1234Cipher cipher = Cipher.getInstance(transformation);cipher.init(Cipher.DECRYPT_MODE, keySpec);byte[] result = cipher.doFinal(data);return new String(result, charset); 使用Base64编码 由于加密之后的byte二进制不便于传输，这里将字节数组编码为Base64，在解密时，先将Base64解码为密文原文，然后再进行解密。 这里使用Android sdk包下面的Base64，如果使用java库下面的Base64，则需要API版本大于26，也就是Android8.0。 1234//编码为Base64Base64.encodeToString(input, Base64.NO_WRAP);//Base64解码Base64.decode(input, Base64.NO_WRAP); 第一个参数为编解码字节数组，第二个参数为编码方式，这个编解码模式，一般采用NO_WRAP。 Base64编解码模式： NO_WRAP：略去所有的换行符 CRLF：Win风格的换行符，使用CR LF这一对作为一行的结尾而不是Unix风格的LF DEFAULT：使用默认的方法来编码 NO_PADDING：略去编码字符串最后的\"=\" URL_SAFE：编码时不使用对URL和文件名有特殊意义的字符来作为编码字符，具体就是以-和_取代+和/ 完整工具类代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class AesUtil { //加密算法 private static final String algorithm = \"AES\"; //模式 private static final String transformation = \"AES/ECB/PKCS5Padding\"; //字符集 private static final String charset = \"UTF-8\"; /** * 加密后转为Base64编码 * * @param key 秘钥 16位 * @param data 原文 * @return Base64密文 */ public static String encryptToBase64(String key, String data) { try { if (!TextUtils.isEmpty(data)) { byte[] valueByte = encrypt(data.getBytes(charset), key.getBytes(charset)); return encodeBase64(valueByte); } return \"\"; } catch (Exception e) { e.printStackTrace(); return \"\"; } } /** * 解密Base64编码的密文 * * @param key 秘钥 16位 * @param data Base64密文 * @return 原文 */ public static String decryptFromBase64(String key, String data) { try { return decrypt(decodeBase64(data), key.getBytes(charset)); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return \"\"; } /** * 编码为Base64 * * @param input 原文 * @return 编码后密文 */ public static String encodeBase64(byte[] input) { return Base64.encodeToString(input, Base64.NO_WRAP); } /** * Base64解码 * * @param input Base64文本 * @return 原文 */ public static byte[] decodeBase64(String input) { try { return Base64.decode(input.getBytes(charset), Base64.NO_WRAP); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return null; } /** * 加密 * * @param data 加密byte数组 * @param key 秘钥byte数组 * @return 密文byte数组 */ public static byte[] encrypt(byte[] data, byte[] key) { try { SecretKeySpec keySpec = new SecretKeySpec(key, algorithm); Cipher cipher = Cipher.getInstance(transformation); cipher.init(Cipher.ENCRYPT_MODE, keySpec); return cipher.doFinal(data); } catch (Exception e) { e.printStackTrace(); } return null; } /** * 解密 * * @param data 密文byte数组 * @param key 秘钥byte数组 * @return 原文 */ public static String decrypt(byte[] data, byte[] key) { try { SecretKeySpec keySpec = new SecretKeySpec(key, algorithm); Cipher cipher = Cipher.getInstance(transformation); cipher.init(Cipher.DECRYPT_MODE, keySpec); byte[] result = cipher.doFinal(data); return new String(result, charset); } catch (Exception e) { e.printStackTrace(); } return null; }} 最后推荐一本扩展阅读的书：《图解密码技术》这本书用通俗易懂的方式讲解了密码学的演进，里面就有关于AES具体的原理，以及分组密码究竟是什么，可以看一下。 参考 https://blog.csdn.net/xiongya8888/article/details/84947232 https://blog.csdn.net/z191726501/article/details/52778478 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-aes-jia-jie-mi/"},{"title":"关于RecyclerView嵌套ViewPager的问题","text":"解决RecyclerView嵌套ViewPager高度不正常问题 需要解决的问题： ViewPager高度为0 ViewPager的高度，需要统一为所有Item中，最高的那个 解决方案： 自定义ViewPager类，并继承ViewPager并覆盖onMeasure方法，手动计算高度 遍历子布局，取得最大高度，并设置为ViewPager高度 1234567891011121314151617181920212223//展示空间高度为：子Item最大的高度@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { //最大高度 int maxHeight = -1; int count = getAdapter().getCount(); //获取最大高度 for (int i = 0; i &lt; count; i++) { Object o = getAdapter().instantiateItem(this, i); if (o instanceof View) { ((View) o).measure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED)); int measuredHeight = ((View) o).getMeasuredHeight(); if (measuredHeight &gt; maxHeight) { maxHeight = measuredHeight; } } } if (maxHeight != -1) { heightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.EXACTLY); } super.onMeasure(widthMeasureSpec, heightMeasureSpec);} 这样，解决了显示高度的问题，但是在嵌套的情况下，会出现ViewPager无法滑动，或只有部分区域可以滑动，所以遇到了下面的问题。 解决RecyclerView嵌套ViewPager无法滑动(滑动事件冲突)问题 解决方法： 在刚才自定义的ViewPager类中，重写onTouchEvent方法 123456789101112131415161718192021222324252627//解决滑动事件冲突无法滑动的问题@Overridepublic boolean onTouchEvent(MotionEvent ev) { if (getChildCount() &lt;= 1) { super.onTouchEvent(ev); } switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: if (getParent() != null) { getParent().requestDisallowInterceptTouchEvent(true); //让事件不再分发 } break; case MotionEvent.ACTION_MOVE: if (getParent() != null) { getParent().requestDisallowInterceptTouchEvent(true); //让事件不再分发 } break; case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_UP: if (getParent() != null) { getParent().requestDisallowInterceptTouchEvent(true); //让事件不再分发 } break; } super.onTouchEvent(ev); return true; //让事件不再分发} 这样，滑动事件就可以正常响应了。 最后，补充一个不使用Fragment，使用View来填充的ViewPager实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class ViewPagerAdapter extends PagerAdapter { private Context mContext; private List mViewList; //需要添加的View列表 private String mData; //添加的数据 public ViewPagerAdapter(Context mContext, List mViewList) { this.mContext = mContext; this.mViewList = mViewList; } @Override public int getCount() { return mViewList != null ? mViewList.size() : 0; } @NonNull @Override public Object instantiateItem(@NonNull ViewGroup container, int position) { View view = mViewList.get(position); //如果发现子Item存在父布局(一般情况为嵌套RecyclerView的回收问题),先将子Item从父布局中移除 //避免提示\"removeView()\"错误 if (view.getParent() != null) { View parent = (View) view.getParent(); if (parent instanceof ViewGroup){ ((ViewGroup) parent).removeView(view); } } container.addView(view); return view; } @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) { container.removeView((View) object); } @Override public boolean isViewFromObject(@NonNull View view, @NonNull Object object) { return view == object; } public void setData(String strData) { this.mData = strData; for (View view : mViewList) { if (mData != null) { if (view instanceof ChildView) { //添加的子View ((Child) view).setData(strData); } } } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/guan-yu-recyclerview-qian-tao-viewpager-de-wen-ti/"},{"title":"写在博客装修之后","text":"2018年，随着工作开始进入到正轨，总觉得要完成一些以前想要做，但是一直没有时间去做的事情， 于是，我开始尝试搭建一个属于自己的博客。 这个时候实际上已经了解了github pages，但是对于它是如何运行起来的，甚至包括博客需要一个什么样的框架， 却完全不了解。因为从来没有过搭建网站的经验，唯一的经验就是曾经在免费空间上使用Discuz安装脚本， 部署过一个论坛，其余的相关知识基本不了解。 域名，DNS，虚拟主机，Nginx，一个一个并不熟悉知识，一个一个坑过来，但是感觉这个过程还是蛮开心的。 在此期间，了解到WordPress，基于PHP的个人网站框架，研究了一下，发现扩展性非常的强， 但是插件内容的过于丰富，甚至可以说有些臃肿，并不是我理想中博客的样子。并且，部署的依赖非常的多(相对的)， 包括PHP环境，Mysql，Nginx，由于是带有后台管理的，在我对该框架非常不熟悉的情况下， 其实是比较危险的一个行为。因为我平时的学习笔记和文档都是使用Markdown编写，而在本地归档的时候， 也是一个个md文件，我想要一个和自己使用习惯比较相似的框架。 后面在了解WP备份与重新部署的步骤之后，更是让我打消了兴趣，我的目的是想要一个简洁的博客， 随带随走，只需要一个nginx即可，其余什么依赖，我都不需要。这个时候，我就发现了Hexo， 它基本完全满足了我对博客的要求。md直接的支持、基于nodejs、完全支持静态部署等， 让我觉得这是个非常优秀的框架，让我十分心动。 不过由于原始的主题太过简陋，于是开始寻找一个合适的主题，第一次找到了一个十分喜欢， 感觉接近完美的主题–matery。简单的调整，配置与修改后，博客终于开张了。 不过好景不长，在使用了一段时间之后发现，网格式的文章布局，归档的密度和分类密度过小， 并且对分类的支持并不完全符合我的需求之后，我尝试着寻找一个新的替代主题，甚至曾经想过， 自己要不要动手写一个，但是后面随着2019年更加繁忙的工作，这件事就被推迟了。由于这个主题， 没有完全达到我对于知识归档，整理收纳的需求，之后对博客的更新就暂停了。不过，虽然博客的更新进入了暂停， 但是我自己的知识文档的编写却没有停下来过。一直是在本地编写，保存在有道云笔记、印象笔记，DSNote里面。 2020年初，由于新型冠状病毒的肆虐，在家中呆了很长一段时间，萌生了再去找找看博客主题的想法，于是， 在经过一番搜索之后，发现了这个主题Icarus，相比于很多非常好看的主题，Icarus十分简洁，并且分类功能十分得我心， 多级的分类方式，更加适合知识这种需要归纳整理的文字。还有一点就是，很多非常优秀且美观的主题， 发现每一篇博文都需要一张不错的图片才能让整个主题看起来优雅，如果没有图片的时候， 当前博文的页面看起来就十分的奇怪。这并不符合我的思路，因为很多知识整理之后，图片与知识可能并没有什么关联， 并且我也没有太多的时间来弄一张图片作为该文章的头图，知识，很多时候只需要文字足以，在这一点上，Icarus做的足够好。 Hexo其实还支持评论，打赏，点赞等其他的功能，但是对于仅仅作为知识梳理与展示的博客而言， 并非需要的东西，所以我将这些暂时用不到的功能全都关闭了。不过还是打开了访问人数统计， 毕竟上一个版本的博客，并没有这个东西，我也很好奇，我写的这些文字，会不会有人看得到。想想还是蛮有趣的。 博客装修成了自己想要的样子，那么接下来，就是重新梳理知识，学习并上传到博客里面， 我觉得他可以满足我现阶段的所有需求了，也非常感谢Icarus的作者编写的这个简洁好用的博客主题。 2020注定是个不平凡的一年，虽然不知道未来会怎么样，但是我还是选择一下希望，希望新的一年， 能实现一些自我的超越吧。 2020，起航。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/ri-chang/xie-zai-bo-ke-zhuang-xiu-zhi-hou/"},{"title":"ES6的常见知识和常用语法","text":"ES6常用语法 ES6 ECMA Script, Javascript的语言标准 提升JS编写大型的复杂的应用程序的能力(模块化) Babel: ES6 -&gt; ES5的转换器 let, const let定义变量，const定义常量 123456let r = 2;r = 4;console.log(r);---const pi = 3.14;pi = 10;//此时会报错 不能重复定义 123456var foo = 1;var foo = 2;console.log(foo); //2---let bar = 1;let bar = 2; //报错 块级作用域 1234567891011121314151617181920212223// 块级作用域if(true) { var test = 1;}console.log(test); //1---if(true) { let test1 = 2;}console.log(test1); //报错// 块级作用域2let arr = [1, 2, 3, 4];for(var i = 0, iLength = arr.length; i &lt; iLength; i++){ //do sth}console.log(i); // 4 (说明此时程序已经正确执行4次，但是这个变量i本身并不需要作为全局变量)--- let arr = [1, 2, 3, 4];for(let i = 0, iLength = arr.length; i &lt; iLength; i++){ //do sth}console.log(i); //报错 不存在变量提升 123456789console.log(foo);var foo = 1; // undefined //执行顺序var foo;console.log(foo);foo = 1;--- console.log(foo);let foo = 1; // 报错 解构赋值 数组类型的解构赋值 123456let a, b, rest;[a, b] = [1, 2]; //赋值----let a, b, rest;[a, b, ...rest] = [1, 2, 3, 4, 5, 6];//结果为 a = 1; b = 2; rest = [3,4,5,6]; 对象解构赋值 123456789101112let a, b;({ a, b} = { a: 1, b: 2}) //a = 1, b = 2----let a, b, c, rest;[a, b, c = 3] = [1, 2]; //a = 1, b = 2, c = 3 (默认值)[a, b, c] = [1, 2]; //a = 1, b = 2, c = undefined 例子：使用结构赋值做变量交换 1234567891011121314151617181920212223let a = 1;let b = 2;[a, b] = [b, a];//a = 2, b = 1----function f() { return [1, 2];}let a, b;[a, b] = f(); //a = 1, b = 2----function f() { return [1, 2, 3, 4, 5];}let a, b, c;[a, , , b] = f(); //a = 1,b = 4----function f() { return [1, 2, 3, 4, 5];}let a, b, c;[a, ...b] = f(); //a = 1,b = [2,3,4,5][a, , ...b] = f(); //a = 1,b = [3,4,5] 例子：对象结构赋值 123456789101112131415161718192021222324252627282930//对象解构赋值let o = { p: 42, q: true};let { p, q} = o;console.log(p, q); // 42 true----let { a = 10, b = 5} = { a: 3}; //a = 3, b = 5----let metaData = { title: 'abc', test: [{ title: 'test', desc: 'desc' }]}let { title: esTitle, test: [{ title: cnTitle }]} = metaData; //abc, test 箭头函数 参数 =&gt; 表达式/语句 1234567let value = 2;let double = x =&gt; 2 * x;let treble = x =&gt; { return 3 * x;}console.log('double: ', double(value)); //4console.log('treble: ', treble(value)); //6 继承外层作用域(没有独立作用域) 12345678910var obj = { commonFn: function(){ console.log(this); }, arrowFn: () =&gt; { console.log(this); }}obj.commonFn(); //this 指向obj作用域obj.arrowFn(); //this 指向了obj所在作用域，window 不能用作构造函数 12345let Ani = function(){}let ani = new Ani(); //OK---let Ani = () =&gt; {}let ani = new Ani(); //报错 没有prototype属性 12345let commonFn = function(){};let arrowFn = () =&gt; {};console.log(commonFn.prototype); //constructorconsole.log(arrowFn.prototype); //undefined 模板字符串 反引号标识 `` 支持多行字符串 1234567//基本用法let str = `&lt;div&gt; &lt;h1 class=\"title\"&gt;Testh1&gt;div&gt;`;document.querySelector('body').innerHTML = str; //在body中显示字符串 支持变量和表达式 123456789101112131415161718192021222324252627282930//嵌套变量的用法let name = 'Jmeow';let str = `&lt;div&gt; &lt;h1 class=\"title\"&gt;${name}h1&gt;div&gt;`;document.querySelector('body').innerHTML = str;//嵌套函数的用法let getName = () =&gt; { return 'Jmeow Test';};let str = `&lt;div&gt; &lt;h1 class=\"title\"&gt;${getName()}h1&gt;div&gt;`;document.querySelector('body').innerHTML = str;//循环嵌套let names = ['AA', 'BB', 'CC'];let str=` &lt;ul&gt; ${ names.map(name =&gt; `&lt;li&gt;Hi, I am ${name}li&gt;`).join('') } ul&gt;`;document.querySelector('body').innerHTML = str; Promise对象 Promise关键词： resolve 预期结果正确 reject 预期结果失败 then 1234567891011121314151617181920//Promise结构new Promise((resolve, reject) =&gt; { //异步函数 $.ajax({ url: 'http://z.cn/user/get_user_info.do', type: 'post', success(res){ resolve(res); }, error(err){ reject(err); } });}).then((res) =&gt; { //resolve console.log('success:', res);},(err) =&gt; { //reject console.log('success:', err);}); 在没有使用Promise之前 12345678910111213141516171819$.ajax({ url: 'http://z.cn/user/get_user_info.do', type: 'post', success(res){ $.ajax({ url: 'http://z.cn/user/get_count.do', type: 'get', success(res){ resolve(res); }, error(err){ reject(err); } }); }, error(err){ //err }}); 使用Promise的链式请求 12345678910111213141516171819202122232425262728293031323334var promiseFn1 = new Promise((resolve, reject) =&gt; { //异步函数 $.ajax({ url: 'http://z.cn/user/get_user_info.do', type: 'post', success(res){ resolve(res); }, error(err){ reject(err); } });});var promiseFn2 = new Promise((resolve, reject) =&gt; { //异步函数 $.ajax({ url: 'http://z.cn/user/get_count.do', type: 'get', success(res){ resolve(res); }, error(err){ reject(err); } });});promiseFn1.then(() =&gt; { //success console.log('promiseFn1 success'); return promiseFn2;}).then(() =&gt; { console.log('promiseFn2 success');}); 面向对象 类 关键词：class 语法糖 -&gt; 对应function 构造函数，constructor 1234567891011class Animal{ constructor(age){ this.name = 'ani'; this.age = age; } getName(){ return this.name + this.age; }}let animal = new Animal('20');console.log(animal.getName()); //ani20 类的继承 extends 类的继承 super 调用父类的构造函数 1234567891011121314151617181920//类的继承class Animal{ constructor(){ this.name = 'ani'; } getName(){ return this.name; }}//extends后是没有this关键字的，如需要使用，需要使用super()class Cat extends Animal{ constructor(){ super(); this.name = 'cat'; }}let animal = new Animal();let cat = new Cat();console.log(animal.getName());console.log(cat.getName()); 对象 对象里属性的简写 对象里方法的简写 属性名可以为表达式 其他扩展 1234567891011121314151617181920212223242526272829303132333435//对象的用法//ES旧语法var name = 'Jmeow'; age = 18;var obj = { name: name, age: age, getName: function(){ return this.name; }, getAge: function(){ return this.age; }}// ES6语法let name = 'Jmeow', age = 18;let obj = { //变量名可以直接用作对象的属性名称 name, age, //对象里的方法可以简写 getName(){ return this.name; }, //表达式作为属性名或方法名 ['get' + 'Age'](){ return this.age; }}//Object对象的扩展Object.keys(obj);Object.assign({a:1},{b:2}); // {a:1 ,b:2}Object.assign({a:1},{a:2, b:2}); // {a:2 ,b:2} ES6模块化 解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程 CommonJS, AMD, CMD index.js 12345678910111213import { str as string, obj, fn} from './module.js';import foo from './module.js';console.log('name:', obj.name);// console.log('str:', str);console.log('string:', string);console.log('fn:', fn);console.log(foo); module.js 12345678910111213let str = 'string';let obj = { name: 'Jmeow'};let fn = () =&gt; { console.log('module test');};export { str, obj, fn}export default {a:1} index.html 1&lt;script type=\"module\" src=\"./index.js\"&gt;script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/frontend/javascript/es6-de-chang-jian-zhi-shi-he-chang-yong-yu-fa/"},{"title":"前端本地存储相关使用方式","text":"Cookie 用户端保存请求信息的机制 分号分隔的多个key-value字段 存储在本地的加密文件里 域名和路径限制 字段： name：cookie名称 domain：cookie生效的域名 path：cookie生效的路径 expires：cookie过期时间 HttpOnly：用户端不可更改 Session 服务端保存请求信息的机制 sessionId通常存放在cookie里 会话由浏览器控制，会话结束，session失效 12345678//查看当前domain的cookiedocument.cookie;//添加cookievar d = new Date();let str = d.toUTCString();//expires时间不可过期document.cookie = \"name=Jmeow;domain=jmeow.org;path=/index.html;expires=\" + str;//删除cookie，过期时间设置为0即可 LocalStorage 本地存储 H5新特性 有域名限制，不存在作用域概念 只有key-value 没有过期时间 浏览器关闭后不会消失 12345678910//添加localStoragewindow.localStorage.setItem('name','Jmeow');//查看localStoragewindow.localStorage.getItem('name');//删除localStoragewindow.localStorage.removeItem('name');//如果需要存储一个对象，需要转换JSON.stringify()window.localStorage.setItem('name',JSON.stringify({name: 'Jmeow'})); SessionStorage 和localStorage相似 会话结束后会消失 12//添加sessionStoragewindow.sessionStorage.setItem('name','Jmeow'); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/frontend/javascript/qian-duan-ben-di-cun-chu-xiang-guan-shi-yong-fang-shi/"},{"title":"网络相关基础知识","text":"页面加载过程 URL解析 DNS查询 资源请求 浏览器解析 URL结构 12http://www.baidu.com:80/getdata.do?userId=1#title协议 域名 端口 路径 参数 哈希 DNS查询 DNS全称：Domain Name System 浏览器 -&gt; DNS缓存 -&gt; DNS服务器 dns-prefetch 资源请求流程 浏览器 -&gt; 后端服务器 Request-header + 参数(url body) status + Response-header + body 浏览器解析(理想环境) DOM + JS执行(如出现JS，暂停DOM构建，先执行JS) 构建渲染树 布局(确定元素大小和位置) 绘制 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/frontend/wang-luo-xiang-guan-ji-chu-zhi-shi/"},{"title":"HTML5 CSS 基础知识","text":"HTML HTML常见元素 header (一些资源和信息描述) meta title style link script base body div/section/article/aside/header/footer p span/em/strong table/thead/tbody/tr/td ul/ol/li/dl/dt/dd a form/input/select/textarea/button 元素的常见使用 视口：宽度为设备宽度，初始化缩放比例1，最大缩放比例1，用户不可缩放 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"&gt; 指定基础路径 1&lt;base href=\"/\"&gt; HTML标签常见属性 a href 地址 target 打开位置 self / blank img src 图片地址 alt 当src不可用时的替换资源 table td colspan 占据几行 (近似效果-合并单元格) rowspan 占据几列 form target 表单提交的地址 method 表单提交的方法 GET POST enctype 编码方式 url-encode form-data input type value button type select | option value label 与表单相关联 for HTML5新增内容 新区块标签 section 区块 article 区块 nav 导航 aside 不重要内容(广告) HTML元素分类 按默认元素分 块级 block会占整行 div section article aside 行内 inline span em strong inline-block 对内block，对外inline input 按内容分 content model HTML元素嵌套关系 块级元素可以包含行内元素 块级元素不一定能包含块级元素 行内元素一般不能包含块级元素 a可以包含块级元素 常见问题 doctype的作用 让浏览器以标准模式渲染 让浏览器知道元素的合法性 HTML XHTML HTML5 的关系 HTML属于SGML XHTML属于XML，是HTML进行XML严格化的结果 HTML5不属于SGML，XML，比XHTML宽松 HTML5的变化 新的语义化元素 表单增强 新的API(离线，音视频，图形，实时通讯，本地存储，设备能力) 分类和嵌套变更 em和i的区别 em是语义化的标签，表示强调 i是纯样式的标签，表示斜体 HTML5中i不推荐使用，一般使用做图标 语义化的意义是什么 开发者容易理解 机器容易理解结构(搜索、读屏软件) 有助于SEO semantic microdata 哪些元素可以自闭合 表单元素 input 图片 img br hr meta link HTML和DOM的关系 HTML是死的 DOM由HTML解析而来，是活的 JS可以维护DOM property和attribute的区别 attribute是死的，写在html元素中的 property是活的 form的作用有哪些 直接提交表单 使用submit/reset按钮 便于浏览器保存表单 第三方库可以整体提取值 第三方库可以进行表单验证 CSS基础 CSS全称：Cascading Style Sheet 层叠样式表 基本规则 选择器 用于匹配HTML元素 有不同的匹配规则 多个选择器可以叠加 Tips：浏览器对css的解析方式：从右往左进行解析，提高解析速度与效率。 1234选择器{ 属性: 值; 属性: 值;} 选择器分类 元素选择器 a{} 伪元素选择器 ::before{} 类选择器 .link{} 属性选择器 [type = radio]{} 伪类选择器 :hover{} ID选择器 #id{} 组合选择器 [type = checkbox] + label{} 否定选择器 :not(.link){} 通用选择器 *{} 选择器权重 选择器本身的权重 ID选择器 #id{} +100 类 属性 伪类 +10 元素 伪元素 +1 其他选择器 +0 特殊权重规则 !important 优先级最高 元素属性 优先级高 &lt; style &gt; 相同权重 后写的生效 非布局样式 字体，自重，颜色，大小，行高 背景，边框 滚动，换行 粗体，斜体，下划线 其他 字体 字体族 衬线字体 serif 非衬线字体 sans-serif 等宽字体 monospace 手写体 cursive 花体 fantasy 多字体fallback 微软雅黑 &gt; 黑体 &gt; 非衬线字体 iconfont 字体图标 原理：自定义字体，利用伪元素 行高 行高的调整 vertical-align 图片3px缝隙问题： inline元素，与字体大小相关，base-line和底线对其方式不同。 解决方式： vertical-align: bottom display: block 背景 背景颜色 background: red rgb hsl(0,100,100%) rgba,hsla (a为透明度) url(’./a,jpg’) 背景图 渐变色背景 \"-webkit-linear-gradient(left,red,green)\" 从左到右，红色渐变为绿色 \"linear-gradient(to right,red,green)\" 从左到右，红色渐变为绿色 \"linear-gradient(45deg,red 0,green 10%, yellow 50%, blue 20%)\" 45度角渐变 背景图片和属性(雪碧图) 用于性能优化 background-repeat: no-repeat/repeat-x/repeat-y; 不平铺/x方向平铺/y方向平铺(默认平铺) background-position: center top; 指定位置 background-position: 20px 30px; 指定位置 background-size: 100px 50px; //指定背景图大小 base64和性能优化: 一般用于小图标小图片，因为base64转换也需要消耗性能 边框 边框的属性：线形 大小 颜色 border 1px solid red //1px边框 实线 红色 dotted //点状 dashed //虚线 边框背景图 border: 30px solid transparent; border-image: url(./a.png) 30px repeat/round; 边框衔接(三角形) border-bottom: 30px solid red; border-right: 30px solid transparent; 滚动 overflow 滚动行为和滚动条 visible 超出容器部分显示，滚动条隐藏 hidden 超出容器部分隐藏，滚动条隐藏 scroll 超出容器部分允许用户滚动，滚动条一直显示 auto 超出容器部分允许用户滚动，滚动条自动显示 文字折行 overflow-wrap(word-wrap)通用换行控制 是否保留单词 word-break 针对多字节文字 中文句子也是/不是单词 white-space 空白处是否断行 装饰性属性及其他 字重（粗体）font-weight normal bold bolder lighter 100 斜体 font-style:itatic 下划线 text-decoration 指针 cursor 补充：美化checkbox label[for]和id 隐藏原生input :checked + label CSS布局 table 表格布局 123.table{ display: table;} float浮动 + margin inline-block 布局 flexbox布局 position static 静态默认 relative 偏移，不会改变原始占有空间 left top absolute 脱离了整个文档流,不会对其他元素造成影响,相对于body布局 left top fixed 脱离了整个文档流,不会对其他元素造成影响,相对于屏幕 left top document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/frontend/css/html5-css-ji-chu-zhi-shi/"},{"title":"Mac下禁用Chrome跨域检查","text":"在开发时，我们经常会遇到CORS跨域问题，这是由于浏览器的同源策略，这是一种浏览器的安全限制。 但是在本地前后端分离式开发的时候，经常会遇到要本地浏览器调用非同源请求，这个时候可以对后端进行CORS的处理。 但是有时候，出现跨域问题，只是临时开发时才会出现的问题。 那么我们可以暂时关闭浏览器的跨域检查，来简化我们的开发。 需要创建一个存放临时配置文件的目录 这里我们在当前用户目录下创建一个名为tmp的文件夹 1mkdir tmp 在终端中输入以下命令，注意，这里面的user-data-dir需要换成你刚才创建的临时目录 1open -n -a /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --args --user-data-dir=\"/Users/&lt;用户名&gt;/tmp\" --disable-web-security 接下来执行即可，Chrome会提示安全检查已关闭，此时的浏览器最好只用于开发环境下对接口进行测试。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/frontend/mac-xia-jin-yong-chrome-kua-yu-jian-cha/"},{"title":"Python基础知识","text":"数据类型 1234567891011121314# 除求整数print(2//2)# 除小数print(2/2)# python 表示二进制 在数字后面加 0b# 0b10 表示二进制的10print(0b10)# python 表示八进制 在数字后面加 0o# 0o10 表示八进制的10print(0o10)# python 表示十六进制 在数字后面加 0x# 0x10 表示十六进制的10print(0x10)print(0x1F) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#=======进制转换=======#将其他进制数转换为2进制print(bin(10))print(bin(0o7))print(bin(0xE))# 将其他进制数转换为8进制print(oct(888))print(oct(0x7777))print(oct(0b111))# 将其他进制数转换为10进制print(int(0b111))print(int(0o77))print(int(0x11E))# 将其他进制数转换为16进制print(hex(888))print(hex(0o7777))print(hex(0b111))#bool：类型print(type(True))print(type(False))# bool True Falseprint(bool('abc'))print(bool(''))print(bool([]))print(bool([1,2,3]))# 表示复数 complexprint(36j)# 转义字符print('let\\'s go')# 换行print(\"\"\"hello\\nhello\"\"\")# 字符串拼接print(\"hello\"+\"world\")# 字符串计算print(\"hello\" * 3)# 字符串索引(负数为反向查找)print(\"hello\"[0])print(\"hello\"[3])print(\"hello\"[-1])# 字符串截取print(\"hello world\"[0:5])print(\"hello world\"[0:-1])print(\"hello world\"[6:11])# 原始字符串print(r'C:\\Windows')print(R'C:\\Windows') 数组元组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 列表类型 listprint(type([1,2,3,4,5,6]))print(type([\"AA\",\"BB\",2,3,True,False]))# 二维数组print(type([[1,2],[3,4]]))# 数组操作# 使用[]来进行操作，取出的会是字符串，使用[:]进行操作，取出的会是数组print([\"A\",\"B\",\"C\"][0])print([\"A\",\"B\",\"C\"][2])print([\"A\",\"B\",\"C\"][0:2])print([\"A\",\"B\",\"C\"][-1:])print([\"A\",\"B\"] * 3)# 元组print(type((1,2,3)))print(type((1,2,False)))print((1,2,False)[2])# int str list# inprint(3 in [1,2,3,4,5])print(6 in [1,2,3,4,5])print(6 not in [1,2,3,4,5])# 长度操作 lenprint(len(\"HELLO !\"))# 最大最小值 max minprint(max([1,2,3,4,5]))print(min([1,2,3,4,5]))print(min(\"hello\"))# ASICII码 ordprint(ord('w'))print(ord(\" \"))# 集合 set 特点：无序，不重复print({1,2,3,4,4,5})print({1,2,3,4,5})print({6,2,2,3,4,5})# 集合不可通过以下方式操作，因为集合无序# print({6,2,2,3,4,5}[0])print(len({1,2,3}))print(1 in {1,2,3})print(1 not in {1,2,3})# 集合的操作# 求两个集合的差集print({2,3,4,5} - {5,6})# 求交集print({2,3,4,5,6} &amp; {5,6,7,8})# 求并集print({2,3,4,5,6} | {5,6,7,8})# typeprint(type({}))print(type(set()))# dict 字典类型 Key Value 不可以有重复key，重复会被覆盖# {key1:value1, key2:value2}print(type({\"AA\":\"aa\", \"BB\":\"bb\"}))# 寻找dict中keyprint({\"A\":\"张\",\"B\":\"王\",\"C\":\"李\",\"D\":\"赵\"}[\"A\"]) 变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273print([1,2,3,4,5] * 3 + [1,2,3] + [1,2,3,4,5])# 变量A = [1,2,3,4,5]B = [1,2,3]print(A * 3 + B + A)# 变量命名规则： 数字，字母，下划线，区分大小写# 保留关键字： and in if importa_b_c = 1d433a = '你好'a_b_c = {1,2,3}# 变量名会覆盖方法名# type = 1# print(type)# int str tuple (不可变)值类型 list set dict(可变) 引用类型a = [1,2,3]b = aa[0] = '1'print(b)# 字符串a1 = 'Hello'a1 = a1 + 'World'print(a1)# id 显示内存地址print(hex(id(a1)))a1 = a1 + 'AAS'print(a1)print(hex(id(a1)))b1 = \"aaa\"print(id(b1))b1 = b1 + \"bbb\"print(id(b1))# 添加元素[] , ()元组不可变A3 = [1,2,3]A3.append(4)print(A3)# 查找元素B1 = (1,2,3,[1,4,5,['b','n','m']])print(B1[3][3][1])# 虽然元组不可变，但是元组中的列表可变B1[3][3][1] = 'K'print(B1[3][3][1])# 运算符 //整除 %取余 **乘方# 比较 and or notprint('abc' == 'abc')print(True and False)print(True or False)print(not True)# 成员运算符 in not inG1 = [1,3,4,5]print(2 in G1)print(2 not in G1)print('2' in G1)# 只取keyG2 = 1print(G2 in {'d':1})G2 = 'd'print(G2 in {'d':1})# 身份运算：F1 = 1F2 = 1.0print(F1 == F2) # 比较数值相等print(F1 is F2) # 比较两个变量的身份是否相等D1 = 2D2 = 2print(id(D1))print(id(D2))# 判断变量类型D3 = 10print(type(D3) == int)print(isinstance(D3,int))print(isinstance(D3,float))print(isinstance(D3,(int,float))) 分支判断 12345678910111213141516171819202122232425262728293031323334353637383940# 这是单行注释'''这是多行注释'''e = 1if e == 1: print(1)else: print(2)# 简单判断测试account = 'AAA'pwd = '111'user_account = input()user_pwd = input()# 逻辑运算符 优先级最低if account == user_account and pwd == user_pwd: print('YES')else: print('NO')# constant 常量# Python 中不存在常量，但是规定常量的写法为：变量名大写# ACCOUNT = 'AAA'if True: pass # 空语句 占位语句# elif -&gt; else ifif True: passelif pwd == 1: passelse: pass# input -&gt; type 'str'ty = input()print(type(ty))A1 = 1A2 = 8print(A1 or A2) 循环 1234567891011121314151617181920212223242526# 循环# whilecounter = 1while counter &lt;= 10: counter += 1 print(counter)else: print('END')# for 遍历，循环，序列或集合字典lista = [1,2,3,4,5]for list_a in lista: # 遍历 print(list_a)listb = [[1,2,3,4,5],('a','b','b')]for x in listb: for y in x: print(y) # break 中断循环else: print('aaa')# 重复指定次数代码循环for x in range(0,10): # for(int i = 0; i &lt; 10; i++) print(x)for x in range(0,10,2): # 2 ：间隔 print(x,end=' | ')for x in range(10,0,-2): # 递减 print(x,end=' | ') document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/other/python-ji-chu-zhi-shi/"},{"title":"JavaBasic-final关键字","text":"关于final关键字 final的优点： final提高了性能，JVM和Java应用都会缓存final变量。 final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。 使用final关键字，JVM会对方法变量及类进行优化。 关于final的重要知识点 final关键字可以用于成员变量、本地变量、方法以及类。 final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。 你不能够对final变量再次赋值。 本地变量必须在声明时赋值。 在匿名类中所有变量都必须是final变量。 final方法不能被重写。 final类不能被继承。 final关键字不同于finally关键字，后者用于异常处理。 final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。 接口中声明的所有变量本身是final的。 final和abstract这两个关键字是反相关的，final类就不可能是abstract的。 final方法在编译阶段绑定，称为静态绑定(static binding)。 没有在声明时初始化final变量的称为空白final变量(blank final variable) 它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。 按照Java代码惯例，final变量就是常量，而且通常常量名要大写： Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Created by Neko on 2017/11/9. */public class Demo1 { //TODO 1 //final可以声明成员变量、方法、类以及本地变量。 //一旦你将引用声明作final，你将不能改变这个引用。 public static final String NAME = \"Name\"; public static void main(String[] args) { //NAME = new String(\"name\"); //报错，因为final变量是只读的 } //TODO 2 class PersonalLoan{ public final String getName(){ return \"personal loan\"; } } class CheapPersonalLoan extends PersonalLoan{ //final 代表这个方法不可以被子类的方法重写 /*@Override public final String getName(){ }*/ } //TODO 3 //使用final来修饰的类叫做final类。final类通常功能是完整的，他们不能被继承。 final class PersonAA{ } //报错 不可以被继承 /*class CheapPersonAA extends PersonAA{ }*/ //TODO 4 //对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容 private final List Loans = new ArrayList(); public void add(){ Loans.add(\"home loan\"); Loans.add(\"personal loan\"); //Loans = new Vector();//报错 不允许 }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/basic/javabasic-final-guan-jian-zi/"},{"title":"算法","text":"冒泡排序 123456789101112131415161718192021222324252627282930/** * Created by Neko~ on 2017/4/10. */public class alg1 { private static int[] data={9,16,27,23,30,49,21,35}; public static void bubbleSort(){ System.out.println(\"开始排序\"); int arraylength = data.length; for(int i = 0; i { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/algorithm/suan-fa/"},{"title":"JavaBasic-ThreadLocal","text":"ThreadLocal ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这个时候该变量是多个线程共享的。 ThreadLocal中，会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。 Demo1 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Created by Neko on 2017/11/9. */public class ThreadL1 { //通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值 private static ThreadLocal seqNum = new ThreadLocal(){ public Integer initialValue(){ return 0; } }; //获取下一个序列值 public int getNextNum(){ System.out.println(\"____\"+seqNum.get()); seqNum.set(seqNum.get()+1); return seqNum.get(); } public static void main(String[] args) { ThreadL1 tl = new ThreadL1(); //三个线程共享tl，各自产生序列号 TestClient t1 = new TestClient(tl); TestClient t2 = new TestClient(tl); TestClient t3 = new TestClient(tl); t1.start(); t2.start(); t3.start(); } private static class TestClient extends Thread{ private ThreadL1 tl; public TestClient(ThreadL1 tl){ this.tl = tl; } public void run(){ for (int i = 0; i&lt;3 ;i++){ //每个线程打出3个序列值 //currentThread()获取当前运行的线程对象 System.out.println(\"Thread[\"+Thread.currentThread().getName()+\"]---&gt;tl[\"+tl.getNextNum()+\"]\"); } } }} Demo2 123456789101112131415161718192021222324252627282930313233/** * Created by Neko on 2017/11/9. */public class ThreadL2 { private Connection conn;//一个非线程安全的变量 public void addTopic1() throws SQLException{ Statement statement = conn.createStatement();//引用非线程安全变量 } //---------------------&gt;使用ThreadLocal这个connection这个非线程安全进行改造 public static ThreadLocal connThreadLocal = new ThreadLocal(); public static Connection getConnection(){ //如果connThreadLocal没有本线程对应的Connection创建一个新的Connection //并将其保存到线程本地变量中 if(connThreadLocal.get() == null){ Connection conn = getConnection(); connThreadLocal.set(conn); return conn; } else { return connThreadLocal.get();//直接返回本地变量 } } public void addTopic() throws SQLException{ //从Threadlocal中获取线程对应的Connection Statement statement2 = getConnection().createStatement(); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/basic/javabasic-threadlocal/"},{"title":"UDP与JavaUDP操作","text":"UDP是什么 全称 User Datagram Protocol 一种用户数据报协议，又称用户数据报文协议 是一个简单的面向数据报的传输层协议，正式规范为RFC 768 用户数据协议、非连接协议 UDP为什么不可靠 它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份 UDP在IP数据报的头部，仅仅加入了复用和数据校验（字段） 发送端生产数据，接收端从网络中抓取数据 结构简单、无校验、速度快、容易丢包、可广播 UDP能做什么 DNS TFTP SNMP 视频、音频、普通无关紧要数据 UDP报文头 两组0-32，一共64为bit 第一组 0-15 Source Port 发送端口号 16-31 Destination Port 接受端口号 第二组 0-15 Length 长度 16-31 Header and Data Checksum 头部和数据校验 UDP包最大长度 16位-&gt;2字节 存储长度信息 2^16-1 = 64K - 1 = 65536 - 1 = 65535 自身协议占用：32+32位 = 64位 = 8字节 65535 - 8 = 65507 byte Java UDP API DatagramSocket 作用 用于接收与发送UDP的类, 负责发送某一个UDP包，或者接受UDP包 不同于TCP，UDP并没有合并到SocketAPI中 API DatagramSocket() 创建简单实例，不指定端口与IP DatagramSocket(int port) 创建监听固定端口的实例 DatagramSocket(int port, InetAdderss loaclAddr)创建固定端口指定IP的实例，当本地存在多个IP的情况下 receive(DatagramPacket d) 接受 send(DatagramPacket d) 发送 setSoTimeout(int timeout) 设置超时，毫秒 close() 关闭、释放资源 DatagramPacket 作用 用于处理报文 将byte数组、目标地址、目标端口等数据包装成报文或者将报文拆卸成byte数组 是UDP的发送实体，也是接收实体 API DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port) 前面3个参数指定buf的使用区间 后面2个参数指定目标机器地址与端口 DatagramPacket(byte[] buf, int length, SocketAddress address) 前面3个参数指定buf的使用区间 SocketAddress相当于InetAddress + Port setData(byte[] buf, int offset, int length) setData(byte[] buf) setLength(int length) setAddress(InetAddress iaddr) setPort(int iport) setSocketAddress(SocketAddress address) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/basic/udp-yu-javaudp-cao-zuo/"},{"title":"使用swagger自动生成html文档","text":"使用swagger自动生成html文档 使用方法 1234567891011121314--启动类添加注解--@EnableSwagger2--添加依赖--&lt;dependency&gt; &lt;groupId&gt;io.springfoxgroupId&gt; &lt;artifactId&gt;springfox-swagger2artifactId&gt; &lt;version&gt;2.7.0version&gt;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfoxgroupId&gt; &lt;artifactId&gt;springfox-swagger-uiartifactId&gt; &lt;version&gt;2.7.0version&gt;dependency&gt; 启动后访问地址 http://localhost:8060/swagger-ui.html swagger 常用注解 @ApiOperation(value = \"用户查询服务\") 标记方法名 123@ApiOperation(value = \"用户查询服务\")public List query(@RequestParam String username){} @ApiModelProperty(value = \"年龄\") 标记在元素上，表名该元素作用 12@ApiModelProperty(value = \"年龄\")private int age; @ApiParam(\"用户id\") 标记在方法的请求参数上 1public User getInfo(@ApiParam(\"用户id\") @PathVariable String id) {} SpringBoot集成Swagger2中遇到的问题 Spring Boot自动配置本身不会自动把/swagger-ui.html这个路径映射到对应的目录META-INF/resources/下面。我们加上这个映射即可。代码如下： 1234567891011@Configurationclass WebMvcConfig extends WebMvcConfigurerAdapter { @Override void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"swagger-ui.html\") .addResourceLocations(\"classpath:/META-INF/resources/\") registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") }} 同时，在启动类上添加注解@EnableWebMvc。 当然，为了更加方便使用SpringBoot集成swagger，这个工作可以直接通过定制swagger-starter来完成。 使用WireMock快速伪造RESTful服务 使用方法 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.github.tomakehurstgroupId&gt; &lt;artifactId&gt;wiremockartifactId&gt;dependency&gt; 下载jar运行 1http://wiremock.org/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/javaweb/shi-yong-swagger-zi-dong-sheng-cheng-html-wen-dang/"},{"title":"使用RedisTemplate操作Redis","text":"使用RedisTemplate操作Redis 补充：List,Set,Map 区别 List,Set都继承自Collection接口，Map不是 List特点：元素有放入顺序，元素可以重复 Set特点：元素无放入顺序，元素不可重复，重复元素会被覆盖。 (元素虽然放入无顺序，但是元素在set中的位置是由该元素的HashCode决定的，其位置其实是固定的) Map特点：适合存储键值对的数据 Redis配置：spring-redis.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxIdle\" value=\"1\" /&gt; &lt;property name=\"maxTotal\" value=\"5\" /&gt; &lt;property name=\"blockWhenExhausted\" value=\"true\" /&gt; &lt;property name=\"maxWaitMillis\" value=\"30000\" /&gt; &lt;property name=\"testOnBorrow\" value=\"true\" /&gt; bean&gt; &lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"hostName\" value=\"127.0.0.1\" /&gt; &lt;property name=\"port\" value=\"6379\"/&gt; &lt;property name=\"poolConfig\" ref=\"jedisPoolConfig\" /&gt; &lt;property name=\"usePool\" value=\"true\"/&gt; bean&gt; &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" /&gt; &lt;property name=\"keySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\" /&gt; property&gt; &lt;property name=\"valueSerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\" /&gt; property&gt; &lt;property name=\"hashKeySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/&gt; property&gt; &lt;property name=\"hashValueSerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"/&gt; property&gt; bean&gt;beans&gt; Demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Created by Neko on 2017/11/7. */public class Test1 { public static void main(String[] args) { ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"spring-redis.xml\"); final RedisTemplate redisTemplate = ctx.getBean(\"redisTemplate\",RedisTemplate.class); //添加一个key ValueOperations value = redisTemplate.opsForValue(); value.set(\"key1\",\"HELLO!!\"); //获取这个Key的值 System.out.println(value.get(\"key1\")); //添加一个Hash集合 //HashOperations //key用来区分是来自哪个HashMap //hashkey是HashMap中的key HashOperations hash = redisTemplate.opsForHash(); Map map1 = new HashMap(); Map map2 = new HashMap(); map1.put(\"name\",\"Apple\"); map1.put(\"age\",\"40\"); map2.put(\"name\",\"Orange\"); map2.put(\"age\",\"60\"); hash.putAll(\"map1\",map1); hash.putAll(\"map2\",map2); //获取map System.out.println(\"MAP1: \"+hash.entries(\"map1\")); System.out.println(\"MAP2: \"+hash.entries(\"map2\")); //添加一个list列表 ListOperations list = redisTemplate.opsForList(); list.rightPush(\"oplist1\",\"1st\"); list.rightPush(\"oplist1\",\"2nd\"); list.rightPush(\"oplist1\",\"3rd\"); //输出list System.out.println(list.range(\"oplist1\",0,2)); list.leftPush(\"oplist2\",\"1st\"); list.leftPush(\"oplist2\",\"2nd\"); list.leftPush(\"oplist2\",\"3rd\"); System.out.println(list.range(\"oplist2\",0,2)); list.rightPush(\"oplist3\",\"1st\"); list.rightPush(\"oplist3\",\"2nd\"); list.rightPush(\"oplist3\",\"3rd\"); System.out.println(list.range(\"oplist3\",0,2)); list.leftPush(\"oplist3\",\"1st\"); list.leftPush(\"oplist3\",\"2nd\"); list.leftPush(\"oplist3\",\"3rd\"); System.out.println(list.range(\"oplist3\",0,5)); //添加一个set集合 SetOperations set = redisTemplate.opsForSet(); set.add(\"opSet\",\"Apple\"); set.add(\"opSet\",\"13\"); set.add(\"opSet\",\"13\");//由于是集合，相同的元素会覆盖掉 //输出set集合 System.out.println(set.members(\"opSet\")); //添加有序的set集合 ZSetOperations zset = redisTemplate.opsForZSet(); zset.add(\"opZset\",\"Apple\",2); zset.add(\"opZset\",\"Orange\",0); zset.add(\"opZset\",\"Banana\",1); //输出有序set集合 System.out.println(zset.rangeByScore(\"opZset\",0,2)); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/javaweb/shi-yong-redistemplate-cao-zuo-redis/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Frontend","slug":"Frontend","link":"/tags/Frontend/"},{"name":"HTML5","slug":"HTML5","link":"/tags/HTML5/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"ThreadLocal","slug":"ThreadLocal","link":"/tags/ThreadLocal/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"Frontend","slug":"Frontend","link":"/categories/Frontend/"},{"name":"Javascript","slug":"Frontend/Javascript","link":"/categories/Frontend/Javascript/"},{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"Css","slug":"Frontend/Css","link":"/categories/Frontend/Css/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Basic","slug":"Java/Basic","link":"/categories/Java/Basic/"},{"name":"JavaWeb","slug":"Java/JavaWeb","link":"/categories/Java/JavaWeb/"},{"name":"Algorithm","slug":"Java/Algorithm","link":"/categories/Java/Algorithm/"}]}