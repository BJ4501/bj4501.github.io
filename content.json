{"pages":[{"title":"","text":"Jmeow's Wonderland Jmeow Furry | Code | GameDesign 这里是杰喵的博客，大部分时间会作为学习笔记的 仓库，有时候也会记录点自己的生活点滴。 其实这里应该放一些自我介绍什么的，但是好像也没什么意义。 就这样吧。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"Android布局相关","text":"LinearLayout vertical 垂直排列 horizontal 水平排列 match_parent 控件的宽度或高度会填满其所在的父控件 wrap_content 控件大小由内容决定 gravity android:gravity 可以不考虑当前布局的方向 android:layout_gravity 需要考虑当前布局的方向 center_horizontal|center_vertical 水平居中，竖直居中 权重布局WeightLayout match_parent 被设置weight值的控件，宽度应为该控件的原宽度+父控件的剩余空间*比例 水平方向的线性布局中：使用weight时，需要将宽度设置为0dp 垂直方向的线性布局中：使用weight时，需要将高度设置为0dp first的宽度：match_parent(原宽度)+(match_parent-(match_parent+match_parent))*1/3设，match_parent为a first的宽度：a+(a-2a)*1/3 = 2/3a first的宽度为父控件2/3，即占父控件的2/3份 second的宽度:a+(a-2a)*2/3 = 1/3a second的宽度为父控件1/3，即占父控件的1/3份 Demo 12345678910111213141516171819202122&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" android:background=\"#00ffff\" tools:context=\"net.bj.talker.talktest.WeightActivity\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"first\" android:layout_weight=\"1\" android:background=\"#00ff00\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"second\" android:layout_weight=\"1\" android:background=\"#0000ff\" /&gt;&lt;/LinearLayout&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-bu-ju-xiang-guan/"},{"title":"安卓面试相关知识-1","text":"Service service和线程的区别和场景 安卓线程（主线程-包括UI控件的绘制和事件响应，工作线程） 一般的线程还可以执行一些耗时的异步操作，一般不要在主线程上做耗时操作，会导致ANR service运行在主线程中，系统进程托管 如何管理service生命周期 生命周期1：service会通过绑定服务，进行service和Activity之间的绑定 生命周期2：直接去开启一个服务 这两种生命周期不同。但是共同点是从OnCreate开始到OnDestory结束 service和IntentService的区别 service不是独立的进程，是依赖于应用程序主线程，在service中进行耗时操作也会产生ANR IntentService中会有工作线程去处理耗时操作，任务执行完成之后IntentService会自动停止 启动服务和绑定服务先后次序问题 Android只会为service创建一个实例对象 序列化：Parcelable和Serializable Binder：多进程间通信依赖Binder service和线程的区别和场景 Thread：程序执行的最小单元，它是分配CPU的基本单位 UI线程：主线程中 工作线程（子线程）：耗时异步操作 为了保证应用响应及时，所以尽量不在主线程做耗时操作 Thread的声明周期 新建：new Thread() 就绪：线程已经启动了，正在等待CPU时间 运行：running 正在执行任务 死亡：dead 线程被其他线程杀死，或执行完毕 阻塞：block 由于某种原因，正在运行线程让出自己的CPU时间，并暂停自己的运行 Thread的致命缺点 无法控制！ Service Service是Android的一种机制，服务是运行在主线程上的 轻量级进程间通信机制，在Liunx层 不可以进行耗时操作 Service的生命周期 onCreate onStart onDestory onBind onUnbind 管理Service生命周期 startSerice 启动之后，只会执行一次onCreate 但是onStartCommand()会启动多次，启动次数是与startService相同 stopService onDestory 如果服务已经被绑定的状态下stopService是无法停止服务的 bindService 绑定Service服务 调用onCreate onBind unbindServce 解绑Service服务 调用onUnbind onDestory Service 和 IntentService 不建议在Service中编写耗时的逻辑和操作，可能会引起ANR IntentService IntentService是继承Service并处理异步请求的类 内部有一个工作线程HandlerThread处理耗时操作 IntentService内部是通过消息的方式发送给HandlerThread的，然后由Handler中的Looper来处理消息。 执行完成之后，会自动停止 onHandleIntent 启动服务&amp;绑定服务 先绑定服务后启动服务 绑定的服务会转变为启动服务状态，当绑定的Activity结束时，服务并不会停止 先启动服务后绑定服务 不会转为绑定服务状态，还是会和Activity绑定。即使Activity解除绑定，服务还是回按照启动服务的生命周期进行 启动服务的优先级比绑定服务高 服务在其托管进程的主线程中运行(UI线程) 序列化：Parcelable和Serializable 序列化：内存中对象–&gt;磁盘 反序列化：磁盘中对象–&gt;内存 实现上 Serializable：实现简单，但是内存开销大 serialVersionUID Parcelable：实现复杂，内存开销小 在内存间传输数据，推荐使用。例如：Activity使用Intent传值（组件之间传输数据） binder应用： AIDL AIDL 进程间通信(IPC)机制 2.AIDL创建 创建AIDL：实体对象，新建AIDL文件，make工程 服务端：新建Service，创建Binder对象，定义方法 客户端：实现serviceConnection，BindService 静态注册&amp;动态注册 广播接收器 BoardcastReceiver 静态注册：在Manifest中 1&lt;receiver&gt;&lt;/receiver&gt; 动态注册 (在代码中调用Context.registerReceiver) 在onResume调用registerReceiver 在onPause销毁 unregisterReceiver 在onResume注册，onPause注销原因：防止内存泄露 特点 静态：常驻进程中，不受组件生命周期影响(即使应用程序关闭，如果有广播发送，程序也会被系统唤醒) 动态：跟随组件的生命周期变化 应用场景 静态：需要时刻监听广播(计算每隔一段时间的网络访问量) 动态：需要在特定时刻接收广播 广播接收器在接收到广播之后会自动回调onReceive()方法 默认广播接收器运行在UI线程(ANR注意) Webview Webview常见的坑 API16 WebView.addJavascriptInterface 攻击者使用Java反射机制，执行任意Java对象的方法 Webview在布局文件的使用：webview写在其他容器中时 jsbridge：通过JavaScript构建的桥，web-&gt;native webviewClient.onPageFinished -&gt; webChromeClient.onProgressChanged（更推荐） 后台耗电：解决方法，在Activity中onDestory，一定要销毁掉webview Webview硬件加速导致页面渲染问题：可能会出现页面加载白块，同时界面闪烁(解决方法，暂时关闭硬件加速) 关于Webview的内存泄露问题(webview可能会一直持有Activity引用，不能回收)解决办法 独立进程，简单暴力，不过可能涉及到进程间通信 动态添加WebView，对传入WebView中使用的Context使用弱引用，动态添加WebView意思在布局创建个ViewGroup用来放置WebView，Activity创建时add进来，在Activity停止时remove掉 异步消息处理 Handler Android SDK 提供给开发者方便进行异步消息处理的类 Handler Looper：轮询操作 MessageQueue消息队列：FIFO原则的消息 Handler：会取出当前线程的Looper，Looper从消息队列中取出消息，交给Handler处理 -&gt; handleMessage() Handler发送消息，处理解决消息 总结： Looper类主要是为每个线程开启的单独的消息循环(ThreadLocal) Handler是Looper的一个接口 在非主线程中无法直接new Handler() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/an-zhuo-mian-shi-xiang-guan-zhi-shi-1/"},{"title":"Android RelativeLayout属性","text":"RelativeLayout各个属性 android:layout_above=\"@id/xxx\" --此控件底部的边缘位于设定ID控件的上方 android:layout_below=\"@id/xxx\" --此控件顶部的边缘位于设定ID控件的下方 android:layout_toLeftOf=\"@id/xxx\" --将控件的右边缘和给定ID控件的左边缘对齐 android:layout_toRightOf=\"@id/xxx\" --将控件的左边缘和给定ID控件的右边缘对齐 android:layout_alignLeft=\"@id/xxx\" --将控件的左边缘和给定ID控件的左边缘对齐 android:layout_alignTop=\"@id/xxx\" --将控件的上边缘和给定ID控件的上边缘对齐 android:layout_alignRight=\"@id/xxx\" --将控件的右边缘和给定ID控件的右边缘对齐 android:layout_alignBottom=\"@id/xxx\" --将控件的底边缘和给定ID控件的底边缘对齐 android:layout_alignParentLeft=“true” --将控件的左边缘和父控件的左边缘对齐 android:layout_alignParentTop=“true” --将控件的上边缘和父控件的上边缘对齐 android:layout_alignParentRight=“true” --将控件的右边缘和父控件的右边缘对齐 android:layout_alignParentBottom=“true” --将控件的底边缘和父控件的底边缘对齐 android:layout_centerInParent=“true” --将控件置于父控件的中心位置 android:layout_centerHorizontal=“true” --将控件置于水平方向的中心位置 android:layout_centerVertical=“true” --将控件置于垂直方向的中心位置 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-relativelayout-shu-xing/"},{"title":"Android 自定义CollapsingToolbarLayout动效","text":"面对开发中遇到的需求，怎么办呢？研究呗！ 关联控件 CoordinatorLayout AppBarLayout CollapsingToolbarLayout RecyclerView SwipeRefreshLayout 下面放出全部布局，然后逐一讲解内容实现。 首先看一下完成后的效果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.CoordinatorLayout android:id=\"@+id/coo_root\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/app_bar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"#177FFF\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=\"match_parent\" android:layout_height=\"180dp\" android:minHeight=\"74dp\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed|enterAlwaysCollapsed\" app:statusBarScrim=\"@android:color/transparent\"&gt; &lt;ImageView android:id=\"@+id/iv_bg\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:scaleType=\"fitXY\" android:src=\"@drawable/ic_bg_logo\" app:layout_collapseMode=\"parallax\" app:layout_collapseParallaxMultiplier=\"0.9\" /&gt; &lt;com.dwzq.market.view.trade.reversebond.ExtendToolbar android:id=\"@+id/tv_title\" android:layout_width=\"match_parent\" android:layout_height=\"74dp\" app:contentInsetStart=\"0dp\" app:layout_collapseMode=\"pin\" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!-- 此处放置内容控件，如RecyclerView --&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_hold_list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingLeft=\"10dp\" android:paddingRight=\"10dp\" app:behavior_overlapTop=\"50dp\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;TextView android:id=\"@+id/tv_total_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"30dp\" android:layout_marginTop=\"49dp\" android:text=\"总数值\" android:textColor=\"@color/p_white\" android:textSize=\"14sp\" /&gt; &lt;com.dwzq.market.widget.textview.DigitsFontTextView2 android:id=\"@+id/tv_total_value\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"30dp\" android:layout_marginTop=\"79dp\" android:text=\"90,899.63\" android:textColor=\"@color/p_white\" android:textSize=\"30sp\" /&gt;&lt;/FrameLayout&gt; 折叠部分 首先折叠动效，在MaterialDesign中有类似的实现，就是CollapsingToolbarLayout。 CollapsingToolbarLayout需要被CoordinatorLayout,AppBarLayout包裹后才可正常使用。 这里面需要注意几个参数： app:layout_scrollFlags 这个参数用来确定折叠Toolbar的折叠方式 scroll 当前页面可以滚动 exitUntilCollapsed 滚动结束后，仍然显示Toolbar(折叠的) enterAlwaysCollapsed 需要配合android:minHeight使用，表示最小折叠高度(当需要折叠保留的部分大于Toolbar的高度情况) android:minHeight 配合exitUntilCollapsed使用，保持最小高度 当内容控件(后面会讲)存在高度偏移时app:behavior_overlapTop，此参数需要设置，默认可设置为?actionBarSize 当CollapsingToolbarLayout配合RecyclerView使用的时候，可能会存在最后一项显示不完整，可设置为?actionBarSize来解决 app:statusBarScrim 当进行全面屏适配时，折叠后状态栏的颜色设置，可设置为@android:color/transparent 背景图片部分 由于需求中，Toolbar上存在背景图片，并且需要在折叠中依旧浮动在Toolbar上，设置如下。 在CollapsingToolbarLayout中，第一个子布局放置ImageView做为背景，同时根据需求调整gravity等属性。 需要特殊提示的属性： android:scaleType 这里面有很多选项，具体需要查阅文档。 fitXY 可以不用保持图像的宽高比，从控件的左上角分别对图片的宽和高进行缩放 centerCrop 保持图像的宽高比，进行缩放图像 app:layout_collapseMode=\"parallax\" 视差模式，在折叠的时候会有个视差折叠的效果 app:layout_collapseParallaxMultiplier=\"0.9\" 设置视差范围,0-1越大视差越大 Toolbar部分 由于需求中的Toolbar比常规工具栏多出一部分，用于放置缩小折叠后的值。那么我们自定义一个Toolbar。 使用时需要注意的参数 app:contentInsetStart=\"0dp\" 在自定义Toolbar时，有时会出现左侧有一段空白无法使用，这时候需要进行设置重置空白。 app:layout_collapseMode=\"pin\" 固定模式，收缩到最后固定在顶端。 布局文件 1234567891011121314151617181920212223242526272829&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"74dp\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/fl_value_bar\" android:layout_alignParentTop=\"true\" android:layout_marginLeft=\"20dp\" android:src=\"@drawable/hq_white_back\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/fl_value_bar\" android:layout_alignParentTop=\"true\" android:layout_centerHorizontal=\"true\" android:gravity=\"center_vertical\" android:text=\"标题栏文字\" android:textColor=\"@color/p_white\" android:textSize=\"18sp\" /&gt; &lt;FrameLayout android:id=\"@+id/fl_value_bar\" android:layout_width=\"match_parent\" android:layout_height=\"30dp\" android:layout_alignParentBottom=\"true\" /&gt;&lt;/RelativeLayout&gt; 自定义Toolbar类文件 12345678910111213141516171819202122public class ExtendToolbar extends Toolbar { public ExtendToolbar(Context context) { this(context, null); } public ExtendToolbar(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public ExtendToolbar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } private void init() { LayoutInflater mInflater = LayoutInflater.from(getContext()); View mView = mInflater.inflate(R.layout.toolbar_reverse_bond, null); LayoutParams lp = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.NO_GRAVITY); addView(mView, lp); }} RecyclerView 数据列表部分 在AppBarLayout外，CoordinatorLayout内，放置需要显示的内容，此处可以为NestedScrollView，RecyclerView，但是不推荐使用ScrollView，存在BUG。 当CollapsingToolbarLayout配合RecyclerView使用的时候，可能会存在最后一项显示不完整，可设置CollapsingToolbarLayout属性android:minHeight=\"?actionBarSize\"来解决。 需要介绍的参数： app:behavior_overlapTop=\"50dp\" 当数据列表需要向上偏移进入CollapsingToolbar部分时，可以设置此参数，向上偏移。 app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" 一定需要添加此参数，表示该控件与CollapsingToolbar通过behavior绑定。 Toolbar 展示数据部分 最开始考虑是用behavior来操作控件滑动，但是behavior因为需要依附在Toolbar控件上,通过app:layout_anchor，app:layout_anchorGravity来操作位置，但是难以做到我需要的效果。 那么考虑使用FrameLayout + TextView将控件浮在布局上方，监听Toolbar移动位置，从而改变TextView的大小和位置。 首先需要取得控件在屏幕中的位置，由于控件的位置需要Measure,Layout之后才能获得，那么我们创建一个监听树来监听控件加载完毕的回调。 123456789101112final ViewTreeObserver viewTreeObserver = getActivity().getWindow().getDecorView().getViewTreeObserver();viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { oX = mBinding.tvTotalValue.getLeft(); oY = mBinding.tvTotalValue.getTop(); // 移除GlobalLayoutListener监听 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) { getActivity().getWindow().getDecorView().getViewTreeObserver().removeOnGlobalLayoutListener(this); } }}); 此时我们就获得了控件距离左侧和上方的位置，之后可以根据折叠后的位置、滑动距离、最大滑动距离，来计算出偏移比例，从而展示出动画效果。 1234567891011121314151617181920appBar.addOnOffsetChangedListener((appBarLayout, verticalOffset) -&gt; { int totalScrollRange = appBarLayout.getTotalScrollRange(); int absOffset = Math.abs(verticalOffset); float percent = (float) absOffset / (float) totalScrollRange; //值 int targetX = DisplayUtils.dp2px(96); int targetY = DisplayUtils.dp2px(51); //名称 int targetNameX = DisplayUtils.dp2px(20); if (oX != 0 || oY != 0) { //总市值 标题 mBinding.tvTotalName.setX(oX - (oX - (float) targetNameX) * percent); //总市值 值 mBinding.tvTotalValue.setX(oX + ((float) targetX - oX) * percent); mBinding.tvTotalValue.setY(oY - (oY - (float) targetY) * percent); mBinding.tvTotalValue.setTextSize(TypedValue.COMPLEX_UNIT_SP, 30f - 14f * percent); }}); 完成以上操作后，就可以实现该动画效果了。此时还可以进行一些扩展功能。比如下拉刷新，全屏模式适配。 扩展：下拉刷新 使用原生方案实现下拉刷新，在布局的根部，使用SwipeRefreshLayout包裹全部布局 1234&lt;android.support.v4.widget.SwipeRefreshLayout android:id=\"@+id/refresh_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 由于监听的是下拉时的事件，那么当Toolbar折叠之后的下拉也会被监听到，这并非我所需要的效果，此时需要在addOnOffsetChangedListener中进行一点设置即可。 123456//当Toolbar完全展开之后，才可使用下拉刷新if (verticalOffset &gt;= 0){ refreshLayout.setEnabled(true);}else { refreshLayout.setEnabled(false);} 扩展：全屏适配的一些提示点 fitSystemWindow 针对状态栏适配 根布局调整padding CollapsingToolbarLayout设置状态栏折叠时颜色 app:statusBarScrim=\"@android:color/transparent\" document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-zi-ding-yi-collapsingtoolbarlayout-dong-xiao/"},{"title":"Android应用前后台状态判断","text":"开发中遇到了一个需求，如果应用在非前台的状态超过一定时间，就需要用户重新去登录。如果用户不进行登录，就回到主页。这种类似的需求我在银行类App中见到过。技术点就是如何判断App当前的状态。 但是这里面状态有很多，并不只是前后台。还有App在前台，但是用户锁屏放置的情况，这种情况，也是需要算作用户未使用App的，所以需要判断的状态如下。 应用状态： 从后台切换到前台 从前台切换到后台 用户锁屏 用户解锁手机 总结出需要判断的内容之后，可以开始根据不同状态编写代码了。 判断前后台切换 首先使用ActivityLifecycleCallbacks接口来接收每一个Activity生命周期的回调，因为我们不知道用户会在哪个Activity中切换App状态，所以需要这个回调来统一处理。 这里解释两个回调方法： onActivityResumed 这里是当App到onResume时统一回调，当应用从后台返回前台时候也会走这个方法。 onActivityStopped 这里是当App到onStop时统一回调，当应用从前台进入时候也会走这个方法。！！注意：这个方法不一定会执行(比如切换最近使用APP列表时)，所以需要配合onTrimMemory一起使用。 onTrimMemory是个很神奇的方法，他实际上是App关于内存优化的一个回调。用于让应用程序在不同的状态下进行内存释放，从而避免被系统杀掉进程。本来与前后台切换并没有什么关系，但是当阅读文档时，发现他在这种状态下是会被回调的： TRIM_MEMORY_UI_HIDDEN 它表示应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键导致应用的UI界面不可见．这时候应该释放一些资源。 那么我们可以通过这个状态来判断用户是否切换到后台，与onStop方法配合使用。 补充：TRIM_MEMORY_BACKGROUND也是应用进入后台的回调，不同的手机厂商可能会使用这两个不同的Flag。最好都进行一下判断。 需要用于判断的回调都准备好了，下面来准备一下需要的常量和变量。 12345678910111213141516//APP状态常量//正常状态public static final int STATE_NORMAL = 0;//从后台回到前台或从锁屏状态返回public static final int STATE_BACK_TO_FRONT = 1;//从前台进入后台或进入锁屏状态public static final int STATE_FRONT_TO_BACK = 2;//App状态public static int sAppState = STATE_NORMAL;//标记程序是否进入后台(onStop回调)private boolean isBackFlag = false;//标记程序是否已进入后台(依据onTrimMemory回调)private boolean background = false;//记录从前台进入后台的时间private static long frontToBackTime; 常量准备好后，现在开始编写判断部分的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//在onCreate中注册此部分registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() { //便于观察，这里删去了暂时不需要的方法 @Override public void onActivityResumed(Activity activity) { if (isBackFlag || background) { //执行到这里说明App是从后台返回的 //状态从后台切换为前台 isBackFlag = false; background = false; sAppState = STATE_BACK_TO_FRONT; //TODO：在这里可以处理App从后台返回的逻辑 //通过frontToBackTime与现在时间的计算，判断用户是否超时 } else { //否则是默认状态 sAppState = STATE_NORMAL; } } @Override public void onActivityStopped(Activity activity) { //判断当前activity是否处于前台 if (!DeviceUtils.isCurAppTop(activity)) { //从前台进入后台 sAppState = STATE_FRONT_TO_BACK; //记录从前台进入后台的时间 frontToBackTime = System.currentTimeMillis(); isBackFlag = true; } }});@Overridepublic void onTrimMemory(int level) { super.onTrimMemory(level); // TRIM_MEMORY_UI_HIDDEN是UI不可见的回调, 通常程序进入后台后都会触发此回调,大部分手机多是回调这个参数 // TRIM_MEMORY_BACKGROUND也是程序进入后台的回调, 不同厂商不太一样, 魅族手机就是回调这个参数 if (level == Application.TRIM_MEMORY_UI_HIDDEN || level == TRIM_MEMORY_BACKGROUND) { background = true; //TRIM_MEMORY_COMPLETE表示内存已经很低，系统可能会杀掉我们的应用 } else if (level == Application.TRIM_MEMORY_COMPLETE) { background = !DeviceUtils.isCurAppTop(this); } if (background) { //记录时间 frontToBackTime = System.currentTimeMillis(); sAppState = STATE_FRONT_TO_BACK; } else { sAppState = STATE_NORMAL; }} isCurAppTop是用来判断程序是否是前台进程的工具类，代码如下： 1234567891011121314151617181920212223/** * 判断当前程序是否前台进程 * * @param context * @return */public static boolean isCurAppTop(Context context) { if (context == null) { return false; } String curPackageName = context.getPackageName(); ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; list = am.getRunningTasks(1); if (list != null &amp;&amp; list.size() &gt; 0) { ActivityManager.RunningTaskInfo info = list.get(0); String topPackageName = info.topActivity.getPackageName(); String basePackageName = info.baseActivity.getPackageName(); if (topPackageName.equals(curPackageName) &amp;&amp; basePackageName.equals(curPackageName)) { return true; } } return false;} 判断用户是否进行锁屏解锁 上面的判断方法虽然已经很完整了，但是当用户将App放置前台并锁屏之后，不会触发上面的流程，那么需要对用户锁屏与解锁的状态进行判断了。 这时候我们需要在onCreate注册一个广播接收器，来接收系统锁屏开屏的广播。 这里简单介绍一下相关的三个状态： Intent.ACTION_SCREEN_ON 用户点亮屏幕 Intent.ACTION_SCREEN_OFF 用户锁屏操作 Intent.ACTION_USER_PRESENT 用户解锁屏幕，这时可以看到App了 123456789101112131415161718192021222324252627282930private class ScreenBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (Intent.ACTION_SCREEN_ON.equals(action)) { // 开屏 } else if (Intent.ACTION_SCREEN_OFF.equals(action)) { // 锁屏 if (sAppState != STATE_FRONT_TO_BACK){ //当应用处于后台时，仍会收到广播。所以在后台时，注意不要刷新从前台进入后台的时间。 isBackFlag = true; sAppState = STATE_FRONT_TO_BACK; frontToBackTime = System.currentTimeMillis(); } } else if (Intent.ACTION_USER_PRESENT.equals(action)) { // 解锁 // TODO：在这里可以判断是否超时，从锁屏回到App的状态处理 } }}//在onCreate中注册广播接收器private void startScreenBroadcastReceiver() { ScreenBroadcastReceiver mScreenReceiver = new ScreenBroadcastReceiver(); IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_SCREEN_ON); filter.addAction(Intent.ACTION_SCREEN_OFF); filter.addAction(Intent.ACTION_USER_PRESENT); this.registerReceiver(mScreenReceiver, filter);} 用户如果不进行登录，返回主页 在App类中，创建管理Activity栈的对象。这里面需要一个工具类。ApplicationActivitiesQueue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import android.app.Activity;import java.util.Stack;/** * 管理 Activity 的 视图栈 * From: https://www.jianshu.com/p/7adf0890e6b9 */public class ApplicationActivitiesQueue { private ApplicationActivitiesQueue() { } private static ApplicationActivitiesQueue queue = new ApplicationActivitiesQueue(); public static ApplicationActivitiesQueue ShareActivityQueue() { return queue; } private Stack&lt;Activity&gt; activityStack = new Stack&lt;Activity&gt;(); /** * 获取当前的activity，不做任何操作 */ public Activity currentActivity() { return activityStack.lastElement(); } /** * 只有这俩方法 操作 activityStack不能手动调用（都是自动添加删除的） * addActivity 添加Activity到堆栈 * popCurrentActivity 结束当前Activity * currentActivity */ public void addActivity(Activity activity) { activityStack.push(activity); } public void popCurrentActivity(Activity activity) { activityStack.remove(activity); } /** * 下面的这些方法都是辅助方法 (注意防止当前activity结束当前的导致crash) * 获取当前Activity（堆栈中最后一个压入的） */ // 结束指定的Activity public void finishOneActivity(Activity activity) { if (activity != null) { if (!activity.isFinishing()) { activity.finish(); } } } // 结束指定类名的Activity public void finishOneActivity(Class&lt;?&gt; cls) { for (Activity activity : activityStack) { if (!activity.getClass().equals(cls)) continue; finishOneActivity(activity); return; } } /** * 结束至指定类名Activity(不包括该类名) */ public void finishToActiovity(Class&lt;?&gt; cls) { while (!activityStack.lastElement().getClass().equals(cls)) { activityStack.pop().finish(); if (activityStack.size() == 0) return; } } /** * 结束除指定类名的所有Activity */ public void finishExcludeActivityAllActivity(Class&lt;?&gt; cls) { for (Activity activity : activityStack) { if (activity == null) continue; if (activity.getClass().equals(cls)) continue; finishOneActivity(activity); } } /** * 结束所有Activity */ public void finishAllActivity() { for (Activity activity : activityStack) { if (activity == null) continue; finishOneActivity(activity); } }} 使用方法： 在registerActivityLifecycleCallbacks中的onActivityCreated和onActivityDestroyed将当前Activity添加入视图栈中，之后按需调用视图栈的方法即可。 12345678910111213//Activity队列private ApplicationActivitiesQueue activitiesQueue = ApplicationActivitiesQueue.ShareActivityQueue();registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() { @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) { activitiesQueue.addActivity(activity);//创建 } @Override public void onActivityDestroyed(Activity activity) { activitiesQueue.popCurrentActivity(activity);//退出 }}); 参考 https://www.jianshu.com/p/38ca64901687 https://www.jianshu.com/p/7adf0890e6b9 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-ying-yong-qian-hou-tai-zhuang-tai-pan-duan/"},{"title":"Android自定义Loading提示框","text":"工作需要一个自定义的Loading提示框，那么比起从网络上找第三方库修改，从零做一个Loading更能学到更多的知识，那么我们开始吧。 制作一个旋转的Loading控件 首先需要自定义View来承载动画 创建LoadingView继承自View 初始化画笔和图片资源 1234567private void init() {&nbsp;&nbsp;&nbsp; paint = new Paint(); //画笔 抗锯齿 paint.setFlags(Paint.ANTI_ALIAS_FLAG); //图片资源 loadingPic = decodeResource(getResources(), R.drawable.ic_loading);} 在onMeasure中，获取图片的宽度和高度 由于我们是要对控件进行旋转，所以需要取出旋转的最大直径作为控件的宽高，防止旋转中，图案被遮挡。 1234567891011@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); //获取需要旋转的图片宽高 picWidth = loadingPic.getWidth(); picHeight = loadingPic.getHeight(); //选择直角三角形的第三边，作为直径，作为控件的宽高(因需要旋转) //a^2 + b^2 = c^2 max = (int) Math.sqrt(picWidth * picWidth + picHeight * picHeight); setMeasuredDimension(max, max);} 在onDraw中，对图案进行绘制 12345678910@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); //移动画布中心至图片中心点 canvas.translate(max / 2, max / 2); //图片旋转 canvas.rotate(rate); //画出图片 canvas.drawBitmap(loadingPic, -(picWidth / 2), -(picHeight / 2), paint);} 至此，我们已经把对应的图片绘制到控件上了，一切都还比较常规，没有什么难度，接下来要处理的是动画部分。 首先使用ValueAnimator来做一个将沙漏旋转180度的动画。 1234567891011121314//开始动画public void startAnimate() { animator = ValueAnimator.ofFloat(0, 180); animator.setDuration(650); //设置动画时长 animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { rate = (float) animation.getAnimatedValue(); invalidate(); } }); animator.start();} Loading动画是一个可循环的沙漏，也就是说，只要Loading界面没有关闭，需要一直循环下去。这部分在网络搜索了很久，但是一直没有找到合适的办法。 方法1 - TimerTask + Handler 第一次的尝试，使用TimerTask + Handler进行动画，间隔时间进行动画，这里面要注意一点，在TimerTask的run方法执行UI操作，会弹出异常，因为Android只允许在UI线程进行UI操作。所以需要Handler。 12345678910public void startAnimate() { Timer timer = new Timer(); TimerTask timerTask = new TimerTask() { @Override public void run() { rotate(); } }; timer.schedule(timerTask, 100, 750);} 这种方法虽然可以实现，但是十分的麻烦。所以换了一种思路。从ValueAnimator下手 方法2 - ValueAnimator.INFINITE ValueAnimator中有一个方法setRepeatCount，可以将动画循环执行，经过测试，确实有效，但是，沙漏每旋转一次，中间都需要间隔停止一下，但是这个函数，并不可以设置每次动画循环的间隔。所以我们继续想办法。 1animator.setRepeatCount(ValueAnimator.INFINITE); 方法3 - onAnimationEnd 经查阅资料，发现ValueAnimator可以添加监听，也就是addListener,在监听中，可以对动画的起止等操作进行监听，onAnimationEnd则是在动画执行结束时的监听。那么我们是不是可以，在动画结束之后，设置一个启示延迟，然后再执行动画，下一次动画结束时，仍然会触发这个监听，那么不就可以实现动画的循环了么。setStartDelay方法，可以设置ValueAnimator动画延迟多久开始。 123456789101112131415161718192021//开始动画public void startAnimate() { animator = ValueAnimator.ofFloat(0, 180); animator.setDuration(650); //设置动画时长 animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { rate = (float) animation.getAnimatedValue(); invalidate(); } }); animator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { animator.setStartDelay(300); animator.start(); } }); animator.start();} 最后测试发现，动画可以循环执行，也达到了我所预期的效果 方法4 - AnticipateInterpolator 其实方法3已经是一个很优秀的解法了，在方法3测试的时候，使用的是LinearInterpolator的动画效果。但是经过测试，发现AnticipateInterpolator的动画效果更加的有趣。 AnticipateInterpolator是先回拉一下再进行正常动画轨迹，类似于投掷的动画效果，在旋转中也比较酷炫。但是由于动画变成了一组，也就是说，需要先0-180度旋转，在进行180-360度旋转，那么如何实现一组动画的实现和循环播放呢。 这个时候，就用到了AnimatorSet，它可以对一组ValueAnimator动画进行顺序或特殊需求的播放。但是AnimatorSet,不支持动画的循环播放，那怎么办呢，有着上一个监听器的经验，在AnimatorSet中，我们也发现了监听器的功能，那么就很简单了，在监听动画组播放结束之后，重新执行动画播放即可。 12345678910111213141516171819202122232425262728293031323334353637//一个带动感的动画public void startFastAnimate() { ValueAnimator animatorA = ValueAnimator.ofFloat(0, 180); animatorA.setDuration(750); animatorA.setStartDelay(200); animatorA.setInterpolator(new AnticipateInterpolator()); animatorA.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { rate = (float) animation.getAnimatedValue(); invalidate(); } }); ValueAnimator animatorB = ValueAnimator.ofFloat(180, 360); animatorB.setDuration(750); animatorB.setStartDelay(200); animatorB.setInterpolator(new AnticipateInterpolator()); animatorB.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { rate = (float) animation.getAnimatedValue(); invalidate(); } }); //设置动画链 final AnimatorSet set = new AnimatorSet(); set.playSequentially(animatorA, animatorB); set.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { set.start(); } }); set.start();} 制作Loading载体Dialog 现在，我们就可以播放这个带动感的动画了。但是工作就完成了么，并不是，这只是个View，它的载体，也就是Dialog，需要设置一下。 首先创建一个布局文件，用于放置Loading界面的布局样式 12345678910111213141516&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/widget_loading_background\"&gt; &lt;com.dwzq.market.widget.loading.KLoadingView android:id=\"@+id/k_loading\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"40dp\" android:layout_marginTop=\"10dp\" android:layout_marginRight=\"40dp\" android:layout_marginBottom=\"10dp\" android:padding=\"5dp\" /&gt;&lt;/FrameLayout&gt; 浅灰色背景样式 1234567&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;!--圆角弧度--&gt; &lt;corners android:radius=\"6dp\" /&gt; &lt;!--背景填充色--&gt; &lt;solid android:color=\"#66091018\" /&gt;&lt;/shape&gt; 设置Dialog的主题Style 123456789101112131415&lt;!--加载dialog的style--&gt;&lt;style name=\"loading_dialog\" parent=\"android:style/Theme.Dialog\"&gt; &lt;!-- 是否有边框 --&gt; &lt;item name=\"android:windowFrame\"&gt;@null&lt;/item&gt; &lt;!-- 是否带有标题 --&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;!-- 提示框背景颜色 --&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; &lt;!-- 是否为浮动 --&gt; &lt;item name=\"android:windowIsFloating\"&gt;true&lt;/item&gt; &lt;!-- 是否允许对话框的背景变暗 --&gt; &lt;item name=\"android:backgroundDimEnabled\"&gt;true&lt;/item&gt; &lt;!-- 重叠在window内容区域的前景，用于在title下放置阴影 --&gt; &lt;item name=\"android:windowContentOverlay\"&gt;@null&lt;/item&gt;&lt;/style&gt; 之后就可以通过Dialog来对该Loading界面进行显示了，期间可以进行一些设置，比如，不可点击空白区域取消，设置背景不变暗，设置Loading界面半透明等操作。 123456789101112131415161718192021public static void showLoading(Context context) { Dialog dialog = new Dialog(context, R.style.loading_dialog); View view = LayoutInflater.from(context).inflate(R.layout.widget_k_loading, null); FrameLayout layout = view.findViewById(R.id.root_view); dialog.setContentView(layout); //设置外边空白区域不可点击 dialog.setCanceledOnTouchOutside(false); Window window = dialog.getWindow(); if (window != null){ //设置背景透明 window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); //设置Loading外界面不变暗 WindowManager.LayoutParams lp = window.getAttributes(); lp.dimAmount =0f; window.setAttributes(lp); } KLoadingView view = dialog.findViewById(R.id.k_loading); //开始动画旋转 view.startAnimate(); dialog.show();} 至此，我们就完成了简单的自定义Loading的实现。可以用在项目中了，收工！ 一些Debug的补充 第一版设置Dialog的代码是这样的： 123Dialog dialog = new Dialog(context);dialog.setContentView(R.layout.widget_k_loading);//省略设置逻辑 当时的测试机是Android 6和Android 9，并没有任何问题。但是在兼容性检查中，发现，在Android5.0上，Dialog的位置并非居中，而是靠左或靠右。初步判断是兼容性的问题，但是问题出现在哪里了呢？ 百思不得解之后，我看了一下其他开源Loading库，对于Dialog部分的处理，发现了不同。 1234Dialog dialog = new Dialog(context, R.style.loading_dialog);View view = LayoutInflater.from(context).inflate(R.layout.widget_k_loading, null);FrameLayout layout = view.findViewById(R.id.root_view);dialog.setContentView(layout); 首先是在设置Dialog时，使用了带有Style的重载方法。 1public Dialog(@NonNull Context context, @StyleRes int themeResId) themeResId的注释描述为\"a style resource describing the theme to use for the window\"，也就是描述窗口的主题资源。因为Dialog也是一个window，具体主题参数和解释见正文。 第二个是，setContentView，不同于直接给定一个layoutRes，这里传递了一个View和LayoutParams 1public void setContentView(@NonNull View view, @Nullable ViewGroup.LayoutParams params) 然而为什么会导致这种情况？在5.0的机器上，当注释掉setBackgroundDrawable时，发现了问题所在，实际上包裹LoadingView外层的布局出现了问题，变成了一个长条形的布局。 为了解释这个问题，需要依次查看不同部分的源码，看一下，到底有什么不同。 首先看一下setContentView，这个方法提供了三种重载。 123public void setContentView(@LayoutRes int layoutResID)public void setContentView(@NonNull View view)public void setContentView(@NonNull View view, @Nullable ViewGroup.LayoutParams params) 方法1与23区别比较大，2就是带new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)默认值的3。 12345//来自PhoneWindow.java@Overridepublic void setContentView(View view) { setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));} 这也回答了一个问题，使用setContentView(View)的方式时，无论layout中根容器的宽高是什么，都按照WRAP_CONTENT的方式。而在setContentView(int)中，用户设置的布局，是会被添加到mContentParent中，而mContentParent是由generateLayout()生成的。在这种方式下可以直接通过在layout的根容器中指定宽、高来设置布局的尺寸。但是使用MATCH_PARENT，并不会产生效果。 但是这并不是导致Dialog显示偏移的原因。那来看一下new Dialog时添加的theme，是不是由于这个原因导致的。 查看Dialog构造器部分的代码，发现在没有给定themeId的时候，会使用默认的R.attr.dialogTheme Android Dialog 部分源码 12345678910Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { if (createContextThemeWrapper) { if (themeResId == ResourceId.ID_NULL) { final TypedValue outValue = new TypedValue(); context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, true); themeResId = outValue.resourceId; } mContext = new ContextThemeWrapper(context, themeResId); }} 那么来看一下默认的theme实现是什么样的，或许就可以解释为什么在不同sdk版本下显示存在差异了。文件位置在android-sdk\\platforms\\android-&lt;版本号&gt;\\data\\res\\values\\themes.xml中，但是观察并没有发现差异。 在只继承系统Theme的情况下，5.0和9.0的表现是不同的，5.0是一个长条形的框，而9.0的尺寸是和LoadingView的尺寸相同的。 12&lt;style name=\"loading_dialog\" parent=\"android:style/Theme.Dialog\"&gt;&lt;/style&gt; 暂时没有更好的办法研究问题出现在哪里了，不过问题目前原因是清晰了，就是因为没有设置Dialog的Theme，与setContentView使用的参数无关。至于不同版本真正产生这个区别的原因，先记录下，等待一个答案的机会。 参考 https://www.cnblogs.com/chorm590/p/6854531.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-zi-ding-yi-loading-ti-shi-kuang/"},{"title":"关于RecyclerView嵌套ViewPager的问题","text":"解决RecyclerView嵌套ViewPager高度不正常问题 需要解决的问题： ViewPager高度为0 ViewPager的高度，需要统一为所有Item中，最高的那个 解决方案： 自定义ViewPager类，并继承ViewPager并覆盖onMeasure方法，手动计算高度 遍历子布局，取得最大高度，并设置为ViewPager高度 1234567891011121314151617181920212223//展示空间高度为：子Item最大的高度@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { //最大高度 int maxHeight = -1; int count = getAdapter().getCount(); //获取最大高度 for (int i = 0; i &lt; count; i++) { Object o = getAdapter().instantiateItem(this, i); if (o instanceof View) { ((View) o).measure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED)); int measuredHeight = ((View) o).getMeasuredHeight(); if (measuredHeight &gt; maxHeight) { maxHeight = measuredHeight; } } } if (maxHeight != -1) { heightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.EXACTLY); } super.onMeasure(widthMeasureSpec, heightMeasureSpec);} 这样，解决了显示高度的问题，但是在嵌套的情况下，会出现ViewPager无法滑动，或只有部分区域可以滑动，所以遇到了下面的问题。 解决RecyclerView嵌套ViewPager无法滑动(滑动事件冲突)问题 解决方法： 在刚才自定义的ViewPager类中，重写onTouchEvent方法 123456789101112131415161718192021222324252627//解决滑动事件冲突无法滑动的问题@Overridepublic boolean onTouchEvent(MotionEvent ev) { if (getChildCount() &lt;= 1) { super.onTouchEvent(ev); } switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: if (getParent() != null) { getParent().requestDisallowInterceptTouchEvent(true); //让事件不再分发 } break; case MotionEvent.ACTION_MOVE: if (getParent() != null) { getParent().requestDisallowInterceptTouchEvent(true); //让事件不再分发 } break; case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_UP: if (getParent() != null) { getParent().requestDisallowInterceptTouchEvent(true); //让事件不再分发 } break; } super.onTouchEvent(ev); return true; //让事件不再分发} 这样，滑动事件就可以正常响应了。 最后，补充一个不使用Fragment，使用View来填充的ViewPager实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class ViewPagerAdapter extends PagerAdapter { private Context mContext; private List&lt;View&gt; mViewList; //需要添加的View列表 private String mData; //添加的数据 public ViewPagerAdapter(Context mContext, List&lt;View&gt; mViewList) { this.mContext = mContext; this.mViewList = mViewList; } @Override public int getCount() { return mViewList != null ? mViewList.size() : 0; } @NonNull @Override public Object instantiateItem(@NonNull ViewGroup container, int position) { View view = mViewList.get(position); //如果发现子Item存在父布局(一般情况为嵌套RecyclerView的回收问题),先将子Item从父布局中移除 //避免提示\"removeView()\"错误 if (view.getParent() != null) { View parent = (View) view.getParent(); if (parent instanceof ViewGroup){ ((ViewGroup) parent).removeView(view); } } container.addView(view); return view; } @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) { container.removeView((View) object); } @Override public boolean isViewFromObject(@NonNull View view, @NonNull Object object) { return view == object; } public void setData(String strData) { this.mData = strData; for (View view : mViewList) { if (mData != null) { if (view instanceof ChildView) { //添加的子View ((Child) view).setData(strData); } } } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/guan-yu-recyclerview-qian-tao-viewpager-de-wen-ti/"},{"title":"解决Dagger2+DataBinding编译错误提示问题","text":"项目中使用了Dragger2+DataBinding这两个基于Annotation的库，这种库依赖于编译期生成代码来使用。但是他们之间会相互影响，一但一个出错了，会导致Annotation编译时中断。这时Java部分编译检查就会爆出大量的错误，错误原因基本都是DataBinding和Dragger编译期生成的中间类无法找到。这时由于默认编译器只会显示100条错误信息，就会导致我们无法定位到真正的错误位置。 那么如何解决这个问题呢，通过对build.gradle配置文件的修改，使其可以显示超过100条错误信息，这时候我们就可以看到代码真正出现问题的地方了。 具体操作如下： 在项目根目录的build.gradle文件中，在allprojects下添加如下代码。这里填写的是5000，也就是说可以最多显示5000条错误信息，这里可以按照真正的需求来修改。（由于项目非常大，我这里最终提示了2000条错误信息） 12345afterEvaluate { tasks.withType(JavaCompile.class) { options.compilerArgs &lt;&lt; \"-Xmaxerrs\" &lt;&lt; \"5000\" }} 这样就可以定位到真正的问题了，如果错误信息庞大，可以对错误信息进行筛选即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/jie-jue-dagger2-databinding-bian-yi-cuo-wu-ti-shi-wen-ti/"},{"title":"Android AES加解密","text":"项目需要对特定数据进行加密，看了一下网上的很多实现，在不同版本的安卓上需要做一些特殊处理。那么我想试着编写一个通用性比较强，不需要对版本进行适配的AES加解密库。 这个库还可以将AES的密文进行Base64编码之后进行传输，算是功能上的补充。 AES 加密 生成加解密Key 使用SecretKeySpec来将给定数组生成对应的key，由于这里是AES加密，所以algorithm为\"AES\" 1SecretKeySpec keySpec = new SecretKeySpec(key, algorithm); 使用Cipher进行加密 Cipher是javax.crypto中的类，他可以提供加解密的功能。使用getInstance方法来构建Cipher对象，并提供转换(加解密)模式。 这里我使用的是AES/ECB/PKCS5Padding模式，这里可以简单的说一下这几个参数的含义。 transformation使用分隔符分割的三个参数分别为：算法/模式/填充，如果找不到对应的方法，会抛出NoSuchAlgorithmException异常。 首先说算法部分，常用的算法有： AES - Advanced Encryption Standard 高级数据加密标准 DES - Data Encryption Standard 数据加密标准 3DES - Triple DES、DESede 进行了三重DES加密的算法 第二部分是，分组密码的工作模式，常用的模式有： ECB - 电子密码本，每次加密均产生独立的密文分组，并且对其他的密文分组不会产生影响，也就是相同的明文加密后产生相同的密文 CBC - 密文链接，明文加密前需要先和前面的密文进行异或运算，也就是相同的明文加密后产生不同的密文 第三部分，分组密码的填充模式： NoPadding - 不进行填充 ZeroPadding - 数据长度不对齐时使用0填充，否则不填充 PKCS5Padding - PKCS7Padding的子集，块大小固定为8字节 PKCS7Padding - 假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n，如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小 12345Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");//加密模式cipher.init(Cipher.ENCRYPT_MODE, keySpec);//按单部分操作加密或解密数据return cipher.doFinal(data); 使用Cipher进行解密 解密方式与加密方式很相似，在init方法中使用的是Cipher.DECRYPT_MODE，也就是解密模式。由于此时解密完毕的是原文的字节数组，所以需要按照编码格式转换为String。 charset中填入编码时使用的字符集，这里是UTF-8。 1234Cipher cipher = Cipher.getInstance(transformation);cipher.init(Cipher.DECRYPT_MODE, keySpec);byte[] result = cipher.doFinal(data);return new String(result, charset); 使用Base64编码 由于加密之后的byte二进制不便于传输，这里将字节数组编码为Base64，在解密时，先将Base64解码为密文原文，然后再进行解密。 这里使用Android sdk包下面的Base64，如果使用java库下面的Base64，则需要API版本大于26，也就是Android8.0。 1234//编码为Base64Base64.encodeToString(input, Base64.NO_WRAP);//Base64解码Base64.decode(input, Base64.NO_WRAP); 第一个参数为编解码字节数组，第二个参数为编码方式，这个编解码模式，一般采用NO_WRAP。 Base64编解码模式： NO_WRAP：略去所有的换行符 CRLF：Win风格的换行符，使用CR LF这一对作为一行的结尾而不是Unix风格的LF DEFAULT：使用默认的方法来编码 NO_PADDING：略去编码字符串最后的\"=\" URL_SAFE：编码时不使用对URL和文件名有特殊意义的字符来作为编码字符，具体就是以-和_取代+和/ 完整工具类代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class AesUtil { //加密算法 private static final String algorithm = \"AES\"; //模式 private static final String transformation = \"AES/ECB/PKCS5Padding\"; //字符集 private static final String charset = \"UTF-8\"; /** * 加密后转为Base64编码 * * @param key 秘钥 16位 * @param data 原文 * @return Base64密文 */ public static String encryptToBase64(String key, String data) { try { if (!TextUtils.isEmpty(data)) { byte[] valueByte = encrypt(data.getBytes(charset), key.getBytes(charset)); return encodeBase64(valueByte); } return \"\"; } catch (Exception e) { e.printStackTrace(); return \"\"; } } /** * 解密Base64编码的密文 * * @param key 秘钥 16位 * @param data Base64密文 * @return 原文 */ public static String decryptFromBase64(String key, String data) { try { return decrypt(decodeBase64(data), key.getBytes(charset)); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return \"\"; } /** * 编码为Base64 * * @param input 原文 * @return 编码后密文 */ public static String encodeBase64(byte[] input) { return Base64.encodeToString(input, Base64.NO_WRAP); } /** * Base64解码 * * @param input Base64文本 * @return 原文 */ public static byte[] decodeBase64(String input) { try { return Base64.decode(input.getBytes(charset), Base64.NO_WRAP); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return null; } /** * 加密 * * @param data 加密byte数组 * @param key 秘钥byte数组 * @return 密文byte数组 */ public static byte[] encrypt(byte[] data, byte[] key) { try { SecretKeySpec keySpec = new SecretKeySpec(key, algorithm); Cipher cipher = Cipher.getInstance(transformation); cipher.init(Cipher.ENCRYPT_MODE, keySpec); return cipher.doFinal(data); } catch (Exception e) { e.printStackTrace(); } return null; } /** * 解密 * * @param data 密文byte数组 * @param key 秘钥byte数组 * @return 原文 */ public static String decrypt(byte[] data, byte[] key) { try { SecretKeySpec keySpec = new SecretKeySpec(key, algorithm); Cipher cipher = Cipher.getInstance(transformation); cipher.init(Cipher.DECRYPT_MODE, keySpec); byte[] result = cipher.doFinal(data); return new String(result, charset); } catch (Exception e) { e.printStackTrace(); } return null; }} 最后推荐一本扩展阅读的书：《图解密码技术》这本书用通俗易懂的方式讲解了密码学的演进，里面就有关于AES具体的原理，以及分组密码究竟是什么，可以看一下。 参考 https://blog.csdn.net/xiongya8888/article/details/84947232 https://blog.csdn.net/z191726501/article/details/52778478 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-aes-jia-jie-mi/"},{"title":"Android Drawable动画的实现","text":"有一个需求，需要做一个简单的动画，UI讲动画每一帧的图片都交给了我，那么该如何去做呢？ 这里使用了animation-list来实现此功能，实现方式也很简单，在drawable下创建对应的xml文件即可。 创建动画Drawable 相关参数介绍： oneshot: 动画是否只执行一次 true 只执行一次 false 循环播放动画 android:duration: 动画每一张播放的长度，单位ms 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=\"false\"&gt; &lt;item android:drawable=\"@drawable/loading_01\" android:duration=\"100\" /&gt; &lt;item android:drawable=\"@drawable/loading_02\" android:duration=\"100\" /&gt; &lt;item android:drawable=\"@drawable/loading_03\" android:duration=\"100\" /&gt; &lt;item android:drawable=\"@drawable/loading_04\" android:duration=\"100\" /&gt; &lt;item android:drawable=\"@drawable/loading_05\" android:duration=\"100\" /&gt; &lt;item android:drawable=\"@drawable/loading_06\" android:duration=\"100\" /&gt; &lt;item android:drawable=\"@drawable/loading_07\" android:duration=\"100\" /&gt; &lt;item android:drawable=\"@drawable/loading_08\" android:duration=\"100\" /&gt;&lt;/animation-list&gt; 播放动画 使用AnimationDrawable，获取ImageView中的Drawable，强转后，执行start方法播放动画。 12AnimationDrawable drawable = (AnimationDrawable) imageview.getDrawable();drawable.start(); 停止动画 通过isRunning()来判断动画是否处于播放状态，然后再进行stop停止动画。 123if (drawable.isRunning()) { drawable.stop();} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-drawable-dong-hua-de-shi-xian/"},{"title":"MPAndroidChart自定义坐标轴显示位置","text":"MPAndroidChart是一个非常强大的控件库，并且可定制性非常的强。但是在使用时，有一个需求是， Y坐标轴上的所有数值必须要在图标内部，那么就需要对Y坐标轴的渲染方式进行定制了。 首先创建一个类YAxisRendererFix继承自YAxisRenderer，内部会重写一个方法 drawYLabels，这就是对Y轴文字渲染的关键方法了，你看Canvas都给你了。 介绍一下这四个参数： Canvas c: 画笔，通过canvas来绘制你的文字，在这里就可以定制文字绘制的位置了。 float fixedPosition: X轴位置 float[] positions: Y轴位置，由于是Y轴的文字，所以所有需要绘制的文字位置作为一个数组。 float offset: setYOffset里面的那个偏移值，如果没设置就是0。 那么，代码如下： 12345678910111213141516171819202122232425262728public class YAxisRendererFix extends YAxisRenderer { private Paint mTextPaint; private Rect mTextRect; public YAxisRendererFix(ViewPortHandler viewPortHandler, YAxis yAxis, Transformer trans) { super(viewPortHandler, yAxis, trans); mTextPaint = new Paint(); mTextRect = new Rect(); mTextPaint.getTextBounds(\"A\", 0, 1, mTextRect); } @Override protected void drawYLabels(Canvas c, float fixedPosition, float[] positions, float offset) { // draw for (int i = 0; i &lt; mYAxis.mEntryCount; i++) { String text = mYAxis.getFormattedLabel(i); if (!mYAxis.isDrawTopYLabelEntryEnabled() &amp;&amp; i &gt;= mYAxis.mEntryCount - 1) return; if (i == mYAxis.mEntryCount - 1) { //为了让最上面的Y轴lable value显示到图表里面 offset = mTextRect.height() + Math.abs(offset) * 3; } c.drawText(text, fixedPosition, positions[i * 2 + 1] + offset, mAxisLabelPaint); } }} 如果上面的方式有点突兀。那么还有一种实现方式，让数值均匀的分布在坐标轴的上下。 123456789101112131415@Overrideprotected void drawYLabels(Canvas c, float fixedPosition, float[] positions, float offset) { float allOffset = mTextRect.height() + Math.abs(offset) * 5; // draw for (int i = 0; i &lt; mYAxis.mEntryCount; i++) { String text = mYAxis.getFormattedLabel(i); if (!mYAxis.isDrawTopYLabelEntryEnabled() &amp;&amp; i &gt;= mYAxis.mEntryCount - 1) return; //图表线条均匀分布 float itemOffset = (allOffset / mYAxis.mEntryCount) * i + offset; c.drawText(text, fixedPosition, positions[i * 2 + 1] + itemOffset, mAxisLabelPaint); }} 使用方法： 在barChart下，使用setRendererLeftYAxis进行设置即可。 123//显示在坐标轴内部barChart.setRendererLeftYAxis(new YAxisRendererFix(barChart.getViewPortHandler(), barChart.getAxisLeft(), barChart.getTransformer(barChart.getAxisLeft().getAxisDependency()))); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/mpandroidchart-zi-ding-yi-zuo-biao-zhou-xian-shi-wei-zhi/"},{"title":"Android实现截屏的两种方式","text":"一个需要截屏的需求，并且如果可以做到的话，需要截取用户的状态栏图象。 方法1 使用View的DrawCache来获取当前显示的内容 优点：方法简单。 缺点：无法截取到状态栏的内容，包括时间，电量，wifi，4G状态等。 注意这里要使用Bitmap.createBitmap否则Bitmap可能会被回收造成崩溃。 1234View rootView = activity.getWindow().getDecorView().getRootView();rootView.setDrawingCacheEnabled(true);Bitmap drawingCache = Bitmap.createBitmap(rootView.getDrawingCache());rootView.setDrawingCacheEnabled(false); 方法2 使用MediaProjectionManager MediaProjectionManager是一个系统级的服务，用于采集屏幕上的信息。可以用来实现截屏或录屏操作。 优点：可以截取状态栏的图象信息。 缺点：在各种设备上的体验并不是很好，因为每次都需要确认权限，并且MediaProjectionManager不回收，会造成设备发热等问题。 首先需要获取屏幕截图权限，但是在Android10上的机器会反复弹出采集屏幕的权限提示，无法选择永久允许。 原生可以选择。Android10的MIUI华为测试不可永久允许。 12345678public void requestCapturePermission() { if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) { //5.0 之后才允许使用屏幕截图 return; } MediaProjectionManager mediaProjectionManager = (MediaProjectionManager) getSystemService(Context.MEDIA_PROJECTION_SERVICE); startActivityForResult(mediaProjectionManager.createScreenCaptureIntent(), 1);} 当用户确认权限后，可以在Result的返回中，获取到MediaProjection对象。 12345678910111213141516171819@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); switch (requestCode) { case 1: //REQUEST_MEDIA_PROJECTION if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) { //5.0 之后才允许使用屏幕截图 return; } if (resultCode == Activity.RESULT_OK &amp;&amp; data != null) { MediaProjection mediaProjection = ((MediaProjectionManager) getSystemService(Context.MEDIA_PROJECTION_SERVICE)) .getMediaProjection(Activity.RESULT_OK, data); } else { //如果获取失败的处理，可以选择再次请求 requestCapturePermission(); } break; }} 设置MediaProjection 1234567public void setMediaProjection(MediaProjection mediaProjection) { this.mediaProjection = mediaProjection; screenHeight = DisplayUtils.getScreenHeight(); screenWidth = DisplayUtils.getScreenWidth(); density = App.getInstance().getResources().getDisplayMetrics().density; imageReader = ImageReader.newInstance(screenWidth, screenHeight, PixelFormat.RGBA_8888, 2);} 当开始截屏时，使用virtualDisplay执行以下操作，来获取图像(截屏)，图像信息保存在imageReader中。 12345678910private void startVirtual() { if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) { //5.0 之后才允许使用屏幕截图 return; } virtualDisplay = mediaProjection.createVirtualDisplay(\"ScreenShot\", screenWidth, screenHeight, (int) density, DisplayManager.VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY | DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC, imageReader.getSurface(), null, null);} 提示：截屏这里需要放在Runnable里面执行，否则有可能获取不到图像。 当无法获得Image时，重新执行上面的操作，直到获取到图象为止。 通过imageReader.acquireLatestImage()就可以获取到Image对象，并可以转换成为Bitmap完成截图。 12345678910111213141516171819202122232425262728293031323334private void startScreenShot() { startVirtual(); startCapture();}private void startCapture() { new Handler().postDelayed(new Runnable() { @Override public void run() { Image image = imageReader.acquireLatestImage(); if (image == null) { releaseDisplay(); startScreenShot(); Timber.e(\"Capture Failed\"); return; } int width = image.getWidth(); int height = image.getHeight(); final Image.Plane[] planes = image.getPlanes(); final ByteBuffer buffer = planes[0].getBuffer(); //每个像素的间距 int pixelStride = planes[0].getPixelStride(); //总的间距 int rowStride = planes[0].getRowStride(); int rowPadding = rowStride - pixelStride * width; Bitmap bitmap = Bitmap.createBitmap(width + rowPadding / pixelStride, height, Bitmap.Config.ARGB_8888); bitmap.copyPixelsFromBuffer(buffer); bitmap = Bitmap.createBitmap(bitmap, 0, 0, width, height); image.close(); } }, 100);} 最后执行释放资源的操作 1234567891011private void releaseResourse() { if (virtualDisplay != null) { virtualDisplay.release(); virtualDisplay = null; } if (mediaProjection != null) { mediaProjection.stop(); mediaProjection = null; }} mediaProjection可以释放，但是释放之后，再次请求获取屏幕就需要重新申请权限了。 目前存在的问题，第一张截图有可能为空，再次获取就会正常。 所以说方法2的代码需要优化。但是后面由于获取权限等问题，对于用户过于不友好，换回使用1方法了，所以方法2的步骤仅供参考。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-shi-xian-jie-ping-de-liang-chong-fang-shi/"},{"title":"Android嵌套滑动的处理","text":"开发中，遇到了一个非常复杂的页面。 最外层是一个ViewPager，内层一个ScrollView，上方是主内容部分的Layout，下方是一个可以悬停的Tabbar，以及一个ViewPager，下方ViewPager中还有ScrollView和RecyclerView，并且继承了上拉加载控件SmartRefreshLayout。 由于嵌套了太多的滚动，此时在滑动时出现了非常多不跟手的问题。甚至有时出现内层可滑动，但是外层还没有滑到底，滑动非常不连贯。为了解决这个问题，这次使用了v4包中的NestedScrollView，它可以很好的帮助我们解决滑动问题。 首先自定义一个滑动控件继承自NestedScrollView，复写onNestedPreScroll方法，这个方法是流畅滑动的关键，可以对每次的滑动进行消耗控制。即，当内部滑动到底时，如果外部可以进行滚动，那么在消耗完毕内部的滑动距离之后，开始对外部ScrollView进行滚动。 该方法的参数意义如下： target：当前发生滚动的View dx：横向滚动的距离 dy：纵向滚动的距离 consumed：父布局需要消耗的X,Y距离 123456789101112131415161718192021222324252627@Overridepublic void onNestedPreScroll(View target, int dx, int dy, int[] consumed) { //上推 boolean hiddenTop = dy &gt; 0 &amp;&amp; getScrollY() &lt; headerHeight; //下拉 boolean canScrollVertically; //如果里面内嵌了SmartRefreshLayout,需要判断内部嵌套的RecyclerView是否可以滑动 if (target instanceof SmartRefreshLayout) { canScrollVertically = ((SmartRefreshLayout) target).getChildAt(0).canScrollVertically(-1); } else { canScrollVertically = target.canScrollVertically(-1); } boolean showTop = dy &lt; 0 &amp;&amp; getScrollY() &gt; 0 &amp;&amp; !canScrollVertically; //由外层ScrollView消耗事件 if (hiddenTop || showTop) { scrollBy(0, dy); consumed[1] = dy; }}@Overridepublic boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) { return isEnabled() &amp;&amp; (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0;} 参考： https://www.jianshu.com/p/f55abc60a879 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-qian-tao-hua-dong-de-chu-li/"},{"title":"TextView渲染HTML使用自定义标签","text":"如果需要在一个TextView中，显示多种字体，颜色，大小，粗细等，一种方法是使用SpannableString，另外一种方法就是，使用Html.fromHtml()。 但是默认tag比较的少，这里我只列出自己使用的几个，剩下的可以到文档中去查找 android.text.Html。 用到过的tag： &lt;font color=\"#FFFFFF\"&gt; &lt;/font&gt; 设置颜色 &lt;b&gt; &lt;/b&gt; 加粗 &lt;br/&gt; 换行 使用方法： 这里TextViewSizeLabel就是我们要自定义的标签解析器 1textView.setText(Html.fromHtml(contentHtml, null, new TextViewSizeLabel())); 首先创建类，实现接口Html.TagHandler，复写handleTag函数。 参数解释： boolean opening 是否为Tag的开始，通过获取开始和结束的位置，来获取需要调整效果的文字位置 String tag Tag的名字 Editable output 输出的文本 XMLReader xmlReader Tag后面的参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class TextViewSizeLabel implements Html.TagHandler { private static final String SIZE_NAME = \"size\"; private static final String SIZE_VALUE = \"value\"; private int startIndex = 0; private int endIndex = 0; private String sizeValue = \"\"; @Override public void handleTag(boolean opening, String tag, Editable output, XMLReader xmlReader) { //自定义的标签名 if (!tag.toLowerCase().equals(SIZE_NAME)) { return; } //opening 表示标签的开始 if (opening) { startIndex = output.length(); //获取标签值 sizeValue = getProperty(xmlReader, SIZE_VALUE); } else { endIndex = output.length(); //标签结束，对标签部分字符串进行处理 output.setSpan(new AbsoluteSizeSpan(DisplayUtils.dp2px(FormatUtils.parseFloat(sizeValue))), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); } } //通过反射获取属性 private String getProperty(XMLReader xmlReader, String property) { try { Field elementField = xmlReader.getClass().getDeclaredField(\"theNewElement\"); elementField.setAccessible(true); Object element = elementField.get(xmlReader); Field attsField = element.getClass().getDeclaredField(\"theAtts\"); attsField.setAccessible(true); Object atts = attsField.get(element); Field dataField = atts.getClass().getDeclaredField(\"data\"); dataField.setAccessible(true); String[] data = (String[]) dataField.get(atts); Field lengthField = atts.getClass().getDeclaredField(\"length\"); lengthField.setAccessible(true); int len = (Integer) lengthField.get(atts); for (int i = 0; i &lt; len; i++) { if (property.equals(data[i * 5 + 1])) { return data[i * 5 + 4]; } } } catch (Exception e) { Timber.e(e); } return null; }} 编写好之后，就可以使用如下来对文字的大小进行设置了。 1&lt;size value=\"12\"&gt; &lt;/size&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/textview-xuan-ran-html-shi-yong-zi-ding-yi-biao-qian/"},{"title":"多EditText页面如何清除输入焦点","text":"开发中，如果需要清空EditText的输入焦点，一般情况下都需要使用EditText.clearFocus()。 但在当一个页面中有多个EditText输入框时，clearFocus有时却无效，清空焦点之后，焦点会重新回到第一个EditText。 那么是不是说明clearFocus在多EditText情况下无效呢？ 当然不是，之所以有时候发现EditText.clearFocus()无效是因为：清除focus之后，还会按照先序遍历的顺序查找一个focusInTouchMode的View，并将其设置为focus。而EditText恰好是这第一个符合条件的View。相当于在清除焦点之后，又重新设置成了焦点。 知道了原因之后，解决方法就出来了：找一个在EditText之前的View，并将其设置为可获得焦点focusableInTouchMode。 12android:focusableInTouchMode=\"true\"View.setFocusableInTouchMode(true); 如果不知道怎样找到一个在EditText之前的View的话，可以直接选择它的parent。 判断是否focus： isFocused() 判断自己是否拥有焦点 hasFocus() 它判断自己或着自己的child是否拥有焦点 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/duo-edittext-ye-mian-ru-he-qing-chu-shu-ru-jiao-dian/"},{"title":"解决EditText中InputFilter与联想词输入法冲突","text":"这一天，产品提出了一个神奇的需求：用户姓名设置框限制，允许最多8个汉字或16个英文字母或数字。 简单来说就是长度限制最大为16个字符，一个汉字认为是两个字符。虽然其实跟用户解释一个汉字等于两个字符这件事情是很奇怪的，但是毕竟是需求，我们来实现一下吧。 首先简单说一下要求: 只允许输入数字汉字或英文字母 输入限制为最大16字符 汉字计为2字符，数字和英文计为1字符 当输入超过16字符时(如拼音输入法一次性输入多个文字)，输入内容截取到最大部分 首先由于汉字需要记为2字符，那么最简单的android:maxLength=\"16\"这种方法就不可以使用了。并且由于需要限制输入的内容，那么我们使用InputFilter来控制实现。 创建一个自定义Filter类，继承自InputFilter，并复写filter方法。简单介绍下filter的几个参数: source : 新输入的字符串 start : 新输入的字符串起始下标 end : 新输入的字符串结尾下标 dest : 之前文本框内容 dstart : 原内容起始下标 dend : 原内容结尾下标 而filter的返回值，则是经过自定义规则处理之后，需要输入进去的内容。 判断输入内容是否合法，我使用了正则表达式进行判断，并且对输入的内容进行限制和截取。 核心代码如下： 123456789101112131415161718192021222324252627@Overridepublic CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) { String sourceText = source.toString(); String destText = dest.toString(); //检查输入的是否为中文，英文，数字 Matcher matcher = mPattern.matcher(source); if (!matcher.matches()) { return \"\"; } //验证删除等按键 if (TextUtils.isEmpty(sourceText)) { return \"\"; } int destLength = getLength(destText); int sourceLength = getLength(sourceText); //如果原始字符已经有16个字符了，那么不需要截取 if (destLength &gt;= MAX_LENGTH) { return \"\"; } else if (destLength + sourceLength &gt; MAX_LENGTH) { return splitStr(sourceText, MAX_LENGTH - destLength); } return sourceText;} 经过测试：当输入\"你好你好你好1234\"之后，就不允许输入新的内容了。大功告成，提交代码下班。 可是当第二天测试的报告，却发现了另一个奇怪的现象。当用户使用带联想词功能的输入法时(英文输入法，或者miui的输入法等)，由于用户预输入的拼音和单词，是会被输入法拦截并设置到EditText中，使得filter被反复触发，会导致用户无法输入完整拼音或单词，甚至输入内容重复累加等问题。 打印日志后发现，英文联想词输入法情况下，在sourceText中，竟然包括了dest文本中的内容，那么这个时候如果我们再去判断sourceText的文本，就会触发BUG。 那么有没有什么办法，可以判断用户是否处于联想词输入模式下呢。答案是：有的。 在网络上查询了许久之后，发现了一个很有趣的实现方法，预输入模式下，输入的内容是带有一个下划线的，那么判断输入的这部分内容是否带下划线，就可以判断出输入的内容是在什么模式下的了。 123456789SpannableString ss = new SpannableString(source);Object[] spans = ss.getSpans(0, ss.length(), Object.class);if (spans != null) { for (Object span : spans) { if (span instanceof UnderlineSpan) { //该文本为预输入内容 } }} 添加之后，确实预输入时不会出现输入错乱等问题了，但是最大输入的长度却无法控制了，因为预输入结束后，输入法是直接把内容设置到EditText里了，没有经过Filter。 这时就可以使用一个经常用到的方法addTextChangedListener对输入的内容进行控制，因为任何字符的改变都会经过这里，只要在这里，对超出长度的内容进行截取就可以了。 123456789101112editText.addTextChangedListener(new TextWatcher() { @Override public void onTextChanged(CharSequence s, int start, int before, int count) { String str = s.toString(); //当处于输入法预输入模式下，对输入长度进行校验 if (getLength(str) &gt; MAX_LENGTH) { int splitIndex = getSplitIndex(str, MAX_LENGTH); editText.setText(str.substring(0, splitIndex)); editText.setSelection(editText.length()); } }}); 经过测试，这回可以满足要求了，即使在预输入模式下，也可以正确的限制输入长度，内容和规则了。优化一下代码，将功能整合到bindEditText，方便以后需求的使用。 最后，完整代码如下，使用bindEditText方法，就可以将此规则绑定到目标EditText上了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208public class NameInputFilter implements InputFilter { private static final int MAX_LENGTH = 16; private static final String regCN = \"[\\u4E00-\\u9FA5]\"; private static final String regEnNum = \"[a-zA-Z0-9]\"; private static final String regAll = \"^[\\u4E00-\\u9FA5a-zA-Z0-9]+$\"; private static final String regExceptText = \"((?![\\u4E00-\\u9FA5aa-zA-Z0-9]).)\"; private Pattern mCNPattern; private Pattern mEnNumPattern; private Pattern mPattern; public NameInputFilter() { mPattern = Pattern.compile(regAll); mCNPattern = Pattern.compile(regCN); mEnNumPattern = Pattern.compile(regEnNum); } /** * @param source 新输入的字符串 * @param start 新输入的字符串起始下标 * @param end 新输入的字符串结尾下标 * @param dest 之前文本框内容 * @param dstart 原内容起始下标 * @param dend 原内容结尾下标 * @return 输入内容 */ @Override public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) { String sourceText = source.toString(); String destText = dest.toString(); //当用户处于输入法联想模式下(MIUI的中文输入法，Gboard输入法英文输入联想模式等) //由于输入法会进行文本预设，所以此时不对输入内容进行校验，但是需要对输入字符的情况进行剔除 //因为仍然不允许输入字符。联想词模式下，输入位数的限制由TextChangedListener控制 SpannableString ss = new SpannableString(source); Object[] spans = ss.getSpans(0, ss.length(), Object.class); if (spans != null) { for (Object span : spans) { if (span instanceof UnderlineSpan) { //检查输入的是否为中文，英文，数字 //不符合的替换为空 return sourceText.replaceAll(regExceptText, \"\"); } } } //检查输入的是否为中文，英文，数字 Matcher matcher = mPattern.matcher(source); if (!matcher.matches()) { return \"\"; } //验证删除等按键 if (TextUtils.isEmpty(sourceText)) { return \"\"; } int destLength = getLength(destText); int sourceLength = getLength(sourceText); //如果原始字符已经有16个字符了，那么不需要截取 if (destLength &gt;= MAX_LENGTH) { return \"\"; } else if (destLength + sourceLength &gt; MAX_LENGTH) { return splitStr(sourceText, MAX_LENGTH - destLength); } return sourceText; } /** * 当中文为2字符，英文数字为1字符情况下，文本的长度计算 * * @param str 文本 * @return 文本长度 */ public int getLength(String str) { int length = 0; char[] chars = str.toCharArray(); for (char aChar : chars) { //检查输入的是否为中文 Matcher cnMatcher = mCNPattern.matcher(String.valueOf(aChar)); if (cnMatcher.matches()) { length = length + 2; continue; } //除了中文之外暂只判断为英文或1字节 Matcher matcher = mEnNumPattern.matcher(String.valueOf(aChar)); if (matcher.matches()) { length = length + 1; } } return length; } /** * 获取到需要截取的位置 * * @param str 原str * @param maxLength 最大长度 * @return 从0开始截取的末尾位置 index */ public int getSplitIndex(String str, int maxLength) { int length = 0; int splitIndex = 0; char[] chars = str.toCharArray(); for (char aChar : chars) { //检查输入的数量是否超规格 if (length &gt;= maxLength) { return splitIndex; } //检查输入的是否为中文 Matcher cnMatcher = mCNPattern.matcher(String.valueOf(aChar)); if (cnMatcher.matches()) { length = length + 2; } else { //除了中文之外暂只判断为英文或1字节 length = length + 1; } splitIndex++; } //不需要截取，没有超过最大值 return str.length(); } /** * 截取至符合要求的位置字符串 * * @param str 文本 * @param size 要求长度 * @return */ private String splitStr(String str, int size) { int length = 0; char[] chars = str.toCharArray(); StringBuilder result = new StringBuilder(); for (char aChar : chars) { //检查输入的是否为中文 Matcher cnMatcher = mCNPattern.matcher(String.valueOf(aChar)); if (cnMatcher.matches()) { length = length + 2; //如果添加这个字符不会超过size限额，那么这个字符是可以添加的 if (length &lt;= size) { result.append(aChar); } else { break; } continue; } Matcher matcher = mEnNumPattern.matcher(String.valueOf(aChar)); if (matcher.matches()) { length = length + 1; if (length &lt;= size) { result.append(aChar); } else { break; } } } return result.toString(); } /** * 绑定目标EditText * * @param editText */ public void bindEditText(EditText editText) { editText.setFilters(new InputFilter[]{this}); editText.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { String str = s.toString(); //当处于输入法预输入模式下，对输入长度进行校验 if (getLength(str) &gt; MAX_LENGTH) { int splitIndex = getSplitIndex(str, MAX_LENGTH); editText.setText(str.substring(0, splitIndex)); editText.setSelection(editText.length()); } } @Override public void afterTextChanged(Editable s) { } }); }} 我本以为事情就这样结束了，第二天测试跟我反馈，在华为的手机上，问题依旧存在。 经过对source和dest的比对，我发现，当检测出下划线部分之后，返回处理后的String其实在这里是有问题的。 因为：华为的输入法会判断返回CharSequence是否有下划线，决定是否替换！！ 也就是说，我必须传入原来的，或者说重建一个带下划线的SpannableString才会被处理到。 那么我们在发现符号后，重建一个带下划线的SpannableString。 并且在此时发现，文本长度的过滤和截取，实际上完全由TextChangedListener处理比较好，因为有些输入法在source里面夹带了一些东西，原样传回去才不容易出BUG。 修改后的代码如下： 123456789101112131415161718192021222324252627282930313233343536@Overridepublic CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) { String sourceText = source.toString(); String destText = dest.toString(); //当用户处于输入法联想模式下(MIUI的中文输入法，Gboard输入法英文输入联想模式等) //由于输入法会进行文本预设，所以此时不对输入内容进行校验，但是需要对输入字符的情况进行剔除 //因为仍然不允许输入字符。联想词模式下，输入位数的限制由TextChangedListener控制 SpannableString ss = new SpannableString(source); Object[] spans = ss.getSpans(0, ss.length(), Object.class); if (spans != null) { for (Object span : spans) { if (span instanceof UnderlineSpan) { //检查输入的是否为中文，英文，数字 //不符合的替换为空 String s = sourceText.replaceAll(regExceptText, \"\"); //华为输入法会判断返回CharSequence是否有下划线，决定是否替换 if (s.equals(sourceText)){ return source; }else { SpannableString str = new SpannableString(s); str.setSpan(new UnderlineSpan(),0,s.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); return str; } } } } //检查输入的是否为中文，英文，数字 Matcher matcher = mPattern.matcher(source); if (!matcher.matches() &amp;&amp; !TextUtils.isEmpty(sourceText)) { return \"\"; } return source;} 当然，如果没有这种奇怪的需求就完事皆无了，不是么。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/jie-jue-edittext-zhong-inputfilter-yu-lian-xiang-ci-shu-ru-fa-chong-tu/"},{"title":"Android内存泄露的排查","text":"在一次项目开发中，测试提到了一个问题，在详情数据页左右反复滑动多次，页面会越来越卡顿，加载速度也会越来越慢，需要我排查一下问题。 由于这个详情数据页面是一个Fragment，数据量特别大，并且嵌套在ViewPage中可以左右滑动，并且ViewPage的页数可以非常多。那么首先想到的问题是ViewPage + Fragment，Fragment没有被正确回收导致的。 首先来排查下Fragment的生成逻辑： 12345678@Overridepublic Fragment getFragment(Fragment fragment, int currentPage) { DemoFragment fragment = new DemoFragment(); Bundle bundle = new Bundle(); bundle.putInt(\"page\", currentPage); fragment.setArguments(bundle); return fragment;} 每次翻页都会重新加载Fragment，这点确实可能会导致问题，但是检查自定义控件逻辑后发现，每次切换页面，都会remove旧的Fragment并清空，虽然这样处理并不是很友好，但是并不会导致越来越卡顿。尝试替换原生ViewPager，问题依旧，那么暂时可以排除问题不在这里。 内存泄露排查 那么这时候来看看手机真实的资源状态吧，是什么原因导致他为什么越来越卡顿，是CPU占用过高，还是内存溢出。于是打开了Android Profiler，在资源监控器下，滑动页面，查看占用情况。CPU占用还算正常，但是内存占用竟然随着滑动一直在飙升，最高占用到了1.5G，测试机是4G的内存，1.5G已经占用很多了，并且此时虚拟机已经开始在频繁GC，几乎是1-2秒GC一次，这不对，因为平时APP的内存占用只有200MB左右，正常情况下，GC后内存占用会回到正常水平，这一定是哪里发生了泄露。 首先点击Memory的折线图，点击上方的Dump java heap，此时系统开始读取手机的内存，读取速度取决于占用的大小，经过一段时间的等待，Hrap Dump的页面展示了出来，此时可以看到上方有一个黄色的警告，Leaks竟然有192处，点击Leaks按钮之后，会列出来系统判断出内存泄露的类，点击类会在下方显示没有被回收的实例，再次点击Instance实例，点击右边的References，可以看到是什么类持有了他的引用。那么通过这个引用，结合类中的代码，就可以判断出到底是哪里发生了泄露，进行解决即可。 简单介绍下页面的几个值的含义： Allocations：堆中的实例数 Depth：从任意 GC root 到所选实例的最短 hop 数 Native Size：c/c++层中内存的大小 Shallow Size：此堆中所有实例的总大小 Retained Size：为此类的所有实例而保留的内存总大小（以字节为单位） 解决问题 问题已经定位到了，那么现在该进行解决了。 初步解决的方法，在页面onDestroy的位置主动取消订阅即可。经过这次修改，内存使用回到了正常，内存泄露被解决。但是这并不是根本问题，因为使用了RxLifecycle之后，应该不需要取消订阅才对，RxLifecycle会自动取消的，但是取消订阅功能未生效，这是为什么？ 检查发现是PublishSubject持有了引用，查阅代码发现，是项目中使用RxBus导致的，RxBus是Rxjava中PublishSubject封装后类似EventBus的实现，由于Rxjava使用不当会造成内存泄露，项目中也使用了RxLifecycle来保证Rxjava的订阅会被及时释放。但是从内存泄露的地址来看，确实是因为PublishSubject中依旧持有引用，那么是什么原因导致的呢？ 首先关注到的是RxFragment是否正常起作用了，因为项目是由android support升级到androidx的，但是RxLifecycle并没有进行升级，引用的仍然是support包的Fragment，而这是否会造成生命周期绑定错误呢？讲RxLifecycle升级到androidx版本后，问题依旧。 通过观察RxFragment的源码实现，看到其中是使用了BehaviorSubject类来对生命周期进行控制，并且绑定了Fragment的全部生命周期，当Rxjava的某个订阅到达了原本设定取消订阅的生命周期，便会取消订阅。 LifecycleTransformer中的apply方法，一但满足条件，就会执行takeUntil()来对订阅进行解绑。takeUntil是一个Rxjava操作符，含义为：发出值，直到提供的 observable 发出值，它便完成。以后有机会整理Rxjava知识的时候再细说。 判断是在compose中出现了问题，随后查询到一篇文章中，也提到了这个问题： 在compose的时候 如果until事件是FragmentEvent.DESTROY_VIEW，fragment的请求在onDestoryView之后发出，会出现问题。原因：在onDestoryView的时候，因为请求还没有发出，队列是空的，所以BehaviorSubject$BehaviorDisposable.emitNext不会调用到，而之后，DESTROY_VIEW事件被后面的DESTORY和DETACH事件依次冲掉，所以请求返回时由于事件不是DESTROY_VIEW，所以请求不会被取消，最后请求的回调依然被调用 如果until事件是FragmentEvent.DETACH，那么在onDestoryView和onDetach之间返回了请求结果的话也会发生问题。 而快速滑动翻页确实可能会造成这个问题。而检查代码发现，compose绑定的生命周期，正是FragmentEvent.DESTROY_VIEW，那么将手动订阅删除掉，将绑定的生命周期改为FragmentEvent.DESTROY，再次测试，问题解决。 1.compose(bindUntilEvent(FragmentEvent.DESTROY)) 总结 经过两天一头雾水的排查，各种内存检查工具的使用，Mat的使用，adb查询native的占用，viewpager的修改，甚至进入到PublishSubject，RxLifecycle看源码的实现逻辑，打断点找问题。实际上可以说的东西有很多。最后解决问题的方法反而异常的简单，越看越觉得RxLifecycle的实现方式非常精巧，很多部分甚至完全看不懂为什么要这么实现，甚至由于我对Rxjava的了解非常的浅薄，很多操作符，模式现在都无法领会。也了解到了还有一个takeUntil的操作符，这个操作符其实可以简化很多复杂的逻辑代码。甚至包括发现了AutoDispose这个类似RxLifecycle的库，依赖的是androidx新Lifecycle，后面项目库慢慢升级的时候，也会用到。 一个内存泄露问题，学到了很多，也发现了自己很多不足。 参考： https://blog.csdn.net/fengrui_sd/article/details/77258861 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-nei-cun-xie-lu-de-pai-cha/"},{"title":"Android打印日志到文件","text":"项目遇到一个问题需要排查，由于是偶现的问题，所以需要打印特定的日志并保存下来，但是并不需要将所有的Log都保存下来， 那么就需要一个小工具来解决这个问题了。 逻辑也很简单，当需要写入日志时，调用函数进行写入即可。简单封装下的代码如下，便于使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class LogcatHelper { private static final String FOLDER_NAME = \"TestAppName\"; private static final String FILE_NAME = \"TestAppName\"; private static LogcatHelper INSTANCE = null; private static String PATH_LOGCAT; private LogDumper mLogDumper = null; private int mPId; /** * 初始化目录 */ private void init(Context context) { if (Environment.getExternalStorageState().equals( Environment.MEDIA_MOUNTED)) {// 优先保存到SD卡中 PATH_LOGCAT = Environment.getExternalStorageDirectory() .getAbsolutePath() + File.separator + FOLDER_NAME; } else {// 如果SD卡不存在，就保存到本应用的目录下 PATH_LOGCAT = context.getFilesDir().getAbsolutePath() + File.separator + FOLDER_NAME; } File file = new File(PATH_LOGCAT); if (!file.exists()) { file.mkdirs(); } } public static LogcatHelper getInstance(Context context) { if (INSTANCE == null) { INSTANCE = new LogcatHelper(context); } return INSTANCE; } private LogcatHelper(Context context) { init(context); mPId = android.os.Process.myPid(); } public void start() { if (mLogDumper == null) mLogDumper = new LogDumper(String.valueOf(mPId), PATH_LOGCAT); mLogDumper.start(); } public void stop() { if (mLogDumper != null) { mLogDumper.stopLogs(); mLogDumper = null; } } private class LogDumper extends Thread { private FileWriter writer; public LogDumper(String pid, String dir) { try { writer = new FileWriter(new File(dir, FILE_NAME + \"-\" + MyDate.getFileName() + \".log\"), true); } catch (FileNotFoundException e) { e.printStackTrace(); Timber.e(e); } catch (IOException e) { e.printStackTrace(); } } public void stopLogs() { try { writer.close(); } catch (IOException e) { e.printStackTrace(); } } @SuppressLint(\"CheckResult\") @Override public void run() { RxBus.register(LogData.class) .subscribe(re -&gt; { if (writer != null) { writer.write(re.getData() + \"\\n\"); writer.flush(); } }, ErrorHandlers.high()::handle); } } public static class MyDate { public static String getFileName() { SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); String date = format.format(new Date(System.currentTimeMillis())); return date;// 2012年10月03日 23:41:31 } public static String getDateEN() { SimpleDateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\"); String date1 = format1.format(new Date(System.currentTimeMillis())); return date1;// 2012-10-03 23:41:31 } } public static class LogData { private String data; public LogData(String data) { this.data = MyDate.getDateEN() + \" \" + data; } public String getData() { return data; } public void setData(String data) { this.data = data; } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-da-yin-ri-zhi-dao-wen-jian/"},{"title":"Android指纹识别功能的接入","text":"在指纹识别手机没有大规模普及之前，许多app提供了使用手势密码进行快速登录或解锁的功能。但是在指纹识别大规模普及的今天，安卓的许多app还是仅支持收拾密码登陆功能，一方面是出于安全性的考量，另一方面是出于对适配兼容的担忧。一但用户进行了Root的操作，那么指纹识别的结果将变得不可信。 最近在寻找市面上常用的密码本软件的时候，发现大部分指纹密码软件支持通过生物识别解锁app。也许是指纹识别的兼容支持变好了？查阅资料发现，安卓对指纹识别的功能进行过封装，使用FingerprintManagerCompat可以轻松对指纹识别进行对接操作。身边8台不同品牌和版本的测试机，都可以正常的使用指纹验证功能。 但是由于Android统一封装指纹功能是在Android6.0后才加入的，这里也只对6.0以上的版本进行指纹识别功能适配。 那么来看一下指纹识别该如何去实现和接入吧。这里为了方便接入，讲指纹识别的全部功能，封装到了一个Dialog中，当打开次dialog时，就可以进行指纹识别了。 首先在AndroidManifest.xml中添加权限。Android在9.0时，开始不推荐使用FingerprintManager，开放了新的API，BiometricPrompt。 但是我们仍可以使用FingerprintManagerCompat对指纹识别进行接入。 12&lt;uses-permission android:name=\"android.permission.USE_FINGERPRINT\"/&gt;&lt;uses-permission android:name=\"android.permission.USE_BIOMETRIC\"/&gt; 接下来编写一个简单的指纹验证Dialog布局，代码如下： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"#FFFFFF\" android:orientation=\"vertical\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:layout_marginTop=\"20dp\" android:src=\"@drawable/fingerprint\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"50dp\" android:gravity=\"center\" android:textSize=\"16sp\" android:textColor=\"#000000\" android:text=\"请验证指纹解锁\" /&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1dp\" android:background=\"#339CA6B1\" /&gt; &lt;TextView android:id=\"@+id/tv_cancel\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\" android:gravity=\"center\" android:text=\"取消\" android:textColor=\"#177FFF\" android:textSize=\"16sp\" /&gt;&lt;/LinearLayout&gt; 接下来可以编写Dialog了，全部的代码放在最后，这里只截取关键的部分来说明。 这里继承使用DialogFragment，因为DialogFragment拥有和Fragment一样的生命周期管理能力，便于资源的处理和释放。 首先获取实例对象，并判断设备是否支持指纹识别功能和是否开启了(录入了)指纹。如果系统版本在6.0以下，就直接返回不支持。 123456789101112131415FingerprintManagerCompat mCompat = FingerprintManagerCompat.from(getContext());//判断硬件是否支持指纹if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) { return false;} else { return mCompat != null &amp;&amp; mCompat.isHardwareDetected();}//判断用户是否开启指纹识别if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) { return false;} else { return mCompat != null &amp;&amp; mCompat.hasEnrolledFingerprints();} 之后就可以开始验证了，看一下验证方法authenticate需要的参数： crypto: 需要传入一个加密对象，用于对指纹识别结果进行加密，如果传null，表示无条件相信返回的结果。推荐使用加密，避免指纹识别结果被篡改 flags: 标志位，默认传0即可 cancel: 用于处理取消指纹识别后的行为 callback: 提供了指纹识别完毕后的回调方法，包括成功、失败、异常错误 handler: 默认会使用主线程的Handler，传null即可 其中特殊强调一下第一个参数，crypto的作用是，验证系统返回的指纹识别结果是否被修改过，这里使用了非对称加密，具体的内容可以参考之前的“Android AES加解密”那篇文章，里面对加密相关的类型和参数有详细的讲解。 具体的逻辑也是大同小异，先生成KeyStore，然后通过KeyStore生成Cipher对象，最后通过FingerprintManagerCompat.CryptoObject生成CryptoObject。 最后将参数传入方法，就可以实现指纹识别功能了。全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class FingerprintDialog extends DialogFragment { private static final String DEFAULT_KEY_NAME = \"default_key\"; private FingerprintManagerCompat mCompat; private CancellationSignal mCancellationSignal; private FingerprintManagerCompat.CryptoObject cryptoObject = null; private FingerPrintResult mResult; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = LayoutInflater.from(getContext()).inflate(R.layout.dialog_finger_test, container, false); mCompat = FingerprintManagerCompat.from(getContext()); TextView tvCancel = view.findViewById(R.id.tv_cancel); tvCancel.setOnClickListener(v -&gt; dismiss()); init(); return view; } private void init() { if (!hasDeviceAllow()) { Toast.makeText(getContext(), \"暂不支持此设备\", Toast.LENGTH_SHORT).show(); dismiss(); return; } if (!hasOpenFingerprints()) { Toast.makeText(getContext(), \"此设备未设置指纹\", Toast.LENGTH_SHORT).show(); dismiss(); return; } initKey(); authenticate(); } public boolean hasDeviceAllow() { if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) { return false; } else { return mCompat != null &amp;&amp; mCompat.isHardwareDetected(); } } public boolean hasOpenFingerprints() { if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) { return false; } else { return mCompat != null &amp;&amp; mCompat.hasEnrolledFingerprints(); } } private void initKey() { if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) { return; } try { KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\"); keyStore.load(null); KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\"); KeyGenParameterSpec.Builder builder = new KeyGenParameterSpec.Builder(DEFAULT_KEY_NAME, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setBlockModes(KeyProperties.BLOCK_MODE_CBC) .setUserAuthenticationRequired(true) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7); keyGenerator.init(builder.build()); keyGenerator.generateKey(); initCipher(keyStore); } catch (Exception e) { throw new RuntimeException(e); } } @TargetApi(23) private void initCipher(KeyStore keyStore) { try { SecretKey key = (SecretKey) keyStore.getKey(DEFAULT_KEY_NAME, null); Cipher cipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + \"/\" + KeyProperties.BLOCK_MODE_CBC + \"/\" + KeyProperties.ENCRYPTION_PADDING_PKCS7); cipher.init(Cipher.ENCRYPT_MODE, key); cryptoObject = new FingerprintManagerCompat.CryptoObject(cipher); } catch (Exception e) { throw new RuntimeException(e); } } public void authenticate() { mCancellationSignal = new CancellationSignal(); mCompat.authenticate(cryptoObject, 0, mCancellationSignal, new FingerprintManagerCompat.AuthenticationCallback() { @Override public void onAuthenticationError(int errMsgId, CharSequence errString) { super.onAuthenticationError(errMsgId, errString); Toast.makeText(getContext(), \"指纹识别出现错误\", Toast.LENGTH_SHORT).show(); dismiss(); } @Override public void onAuthenticationSucceeded(FingerprintManagerCompat.AuthenticationResult result) { super.onAuthenticationSucceeded(result); Toast.makeText(getContext(), \"指纹识别成功\", Toast.LENGTH_SHORT).show(); //处理成功之后的回调 mResult.onSuccess(); dismiss(); } @Override public void onAuthenticationFailed() { super.onAuthenticationFailed(); Toast.makeText(getContext(), \"指纹识别失败\", Toast.LENGTH_SHORT).show(); } }, null); } public interface FingerPrintResult{ void onSuccess(); } public void setResult(FingerPrintResult mResult) { this.mResult = mResult; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/android-zhi-wen-shi-bie-gong-neng-de-jie-ru/"},{"title":"AndroidStudio生成模板代码","text":"由于我的项目是MVP分层架构的，其实分层架构本身是一个好事，结构清晰，代码的健壮性强，但是每次创建页面都需要生成四五个类，页面一多，就要重复非常多次，这样的效率太低了，那有没有什么办法可以一次性，将样板代码生成好呢？ 答案当然是有的，注意过么，每次我们通过AndroidStudio创建一个新Activity的时候，是会生成完整Activity模板代码的，那么我们是否可以自定义这个行为呢？ 可以的！方法如下： 首先进入到AndroidStudio软件目录下android-studio\\plugins\\android\\lib\\templates\\activities\\,这里面可以看到很多熟悉的名字，这就是平时使用的模板的存放位置。 在这里可以建立一个模板文件夹，举例为MVPActivity。也可以复制一个模板以此为基础修改。 template_blank_activity.png 这张图片是展示在生成对话框左侧的图片，可以自定义为任何自己喜欢的图片。 template.xml 这个是模板生成菜单的参数配置，可以在这里定义自己需要的参数，这里面的参数会作为后面生成模板的参数。参数的内容其实比较好理解。 id：用户输入的参数，相当于变量名 name：在生成页面里显示的Label名称 type：类型 constraints：约束，包括是否非空等 default：默认值 help；该参数对应的提示信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\"?&gt;&lt;template format=\"5\" revision=\"5\" name=\"MVP Activity\" minApi=\"9\" minBuildApi=\"14\" description=\"Creates a new MVP activity\"&gt; &lt;category value=\"Activity\" /&gt; &lt;formfactor value=\"Mobile\" /&gt; &lt;parameter id=\"className\" name=\"Class Name\" type=\"string\" constraints=\"nonempty\" default=\"Item\" help=\"Your MVP basic name.\" /&gt; &lt;parameter id=\"classDesc\" name=\"Class Desc\" type=\"string\" constraints=\"nonempty\" default=\" \" help=\"Desc your class\" /&gt; &lt;parameter id=\"packageName\" name=\"Package name\" type=\"string\" constraints=\"package\" default=\"com.mycompany.myapp\" /&gt; &lt;!-- 128x128 thumbnails relative to template.xml --&gt; &lt;thumbs&gt; &lt;!-- default thumbnail is required --&gt; &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file=\"globals.xml.ftl\" /&gt; &lt;execute file=\"recipe.xml.ftl\" /&gt;&lt;/template&gt; recipe.xml.ftl 这个是最终需要生成的文件的列表。include里面的是生成Activity对应在AndroidManifest.xml中的条目。如果不需要自动生成，也可以将此行注释掉。 如果需要生成layout文件的话，也可以在这里添加，推荐参考EmptyActivity的模板格式。 没有出现在这里的参数，简单描述一下： copy：从root中复制文件到目标目录，这里是直接复制的操作。 merge：合并，比如将使用到的strings.xml合并到项目的stirngs.xml中。 instantiate：讲ftl文件按照规则转义后，生成到对应文件夹中，类似copy。 open：在代码生成后，打开指定的文件。 12345678910111213&lt;?xml version=\"1.0\"?&gt;&lt;recipe&gt; &lt;#include \"../common/recipe_manifest.xml.ftl\" /&gt; &lt;instantiate from=\"root/src/app_package/EmptyActivity.java.ftl\" to=\"${escapeXmlAttribute(srcOut)}/${ActivityName}.java\" /&gt; &lt;instantiate from=\"root/src/app_package/EmptyFragment.java.ftl\" to=\"${escapeXmlAttribute(srcOut)}/${FragmentName}.java\" /&gt; &lt;instantiate from=\"root/src/app_package/EmptyPresenter.java.ftl\" to=\"${escapeXmlAttribute(srcOut)}/${PresenterName}.java\" /&gt; &lt;instantiate from=\"root/src/app_package/EmptyView.java.ftl\" to=\"${escapeXmlAttribute(srcOut)}/${ViewName}.java\" /&gt;&lt;/recipe&gt; globals.xml.ftl 这里面是id和参数的定义文件，可以理解为变量存放的位置，便于后面ftl文件使用。 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\"?&gt;&lt;globals&gt; &lt;#assign Collection=extractLetters(className)&gt; &lt;#assign ClassDesc=extractLetters(classDesc)&gt; &lt;!-- 生成的页面名称id，用于后面的ftl文件中 --&gt; &lt;global id=\"ActivityName\" value=\"${Collection}Activity\" /&gt; &lt;global id=\"FragmentName\" value=\"${Collection}Fragment\" /&gt; &lt;global id=\"PresenterName\" value=\"${Collection}Presenter\" /&gt; &lt;global id=\"ViewName\" value=\"${Collection}View\" /&gt; &lt;!-- 文件头注释 --&gt; &lt;global id=\"DescContent\" value=\"${ClassDesc}\" /&gt; &lt;!-- 生成AndroidManifest.xml时必须的参数 --&gt; &lt;global id=\"activityClass\" value=\"${Collection}Activity\"/&gt; &lt;!-- 如果不需要将生成页面作为Launcher设置false --&gt; &lt;global id=\"isLauncher\" type=\"boolean\" value=\"false\" /&gt; &lt;!-- 如果需要设置layout文件可以使用 --&gt; &lt;#assign collection_name=Collection?lower_case&gt; &lt;global id=\"activity_layout\" value=\"${Collection?lower_case}\" /&gt; &lt;global id=\"fragment_layout\" value=\"${Collection?lower_case}\" /&gt; &lt;global id=\"hasNoActionBar\" type=\"boolean\" value=\"false\" /&gt; &lt;global id=\"parentActivityClass\" value=\"\" /&gt; &lt;global id=\"excludeMenu\" type=\"boolean\" value=\"true\" /&gt; &lt;global id=\"generateActivityTitle\" type=\"boolean\" value=\"false\" /&gt; &lt;#include \"../common/common_globals.xml.ftl\" /&gt;&lt;/globals&gt; 接下来的就可以在对应的目录下添加模板的ftl文件来设置生成模板代码的类型。 这里以EmptyActivity.java.ftl作为例子，其余的大同小异，也可以查阅FreeMarker的语法。 12345678910111213141516package ${packageName};import ${superClassFqcn};import android.os.Bundle;/** * ${DescContent} * Author: author name */public class ${activityClass} extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); }} 如果遇到修改后无法生成代码的问题也不要慌，AndroidStudio右下角会出现一个红色的叹号，这里面出现的都是AndroidStudio运行时遇到的异常，在这里就可以看到，为什么模板没有成功生成的原因了。 节省的时间，就可以做更有意义的事情了。 参考： https://www.jianshu.com/p/a5f748e2e856 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/androidstudio-sheng-cheng-mo-ban-dai-ma/"},{"title":"一次Android相册的开发日志记录 Day1","text":"我实在受够啦！！！！ 这个市面上就没有简单好用的相册管理软件了么！！！ 尝试了我能找到的市面上所有的相册管理软件，没有一个能完全做到我想的样子。 手机自带的相册软件+云同步确实可以在单个或同品牌手机内，完成我想要的需求，但是我手上的设备众多，每次更换设备不一定会使用原品牌，那么这就变得非常的麻烦了。 我的需求实际相对简单: 1.相对可用的UI，比如三星相册，小米相册 2.照片存储在服务器上，本地只缓存缩略图，只有用到的时候展示全图。 3.支持文件夹管理，这个非常关键。并且对应在服务器的文件目录结构要一致。 4.支持隐藏显示部分相册，保护隐私。 5.支持文件夹-&gt;远程文件夹的定向同步(单向或双向) 但是同时满足这些点的相册，或多或少都有些问题。 WebDav + Solid Explorer 1.满足了1和3 2.但是由于没有缓存，导致每次点开相册都要加载好久，分享照片也是 3.由于是远端挂载的文件夹，如果想要将远端相册的照片保存在本地，需要使用复制，这点十分别扭 4.不支持隐藏 5.不支持同步 这种方案的好处是，通用性极强，无视系统差异，只要拥有WebDav文件管理器即可。 nextCloud 1.UI存在很大问题，相册视图下，图片缩略图过小，间距过大，但是IOS客户端版本相对较好。 2.客户端操作是会出现一些BUG，包括提示不消失等问题 3.只支持单向同步 nextCloud套件功能相对完整，没有强迫症需求的，并且主力机是IOS设备的，可以考虑一下。 不过如果常用设备是IOS的话，用iCloud不香么？ 群晖DSPhoto 1.不支持1和4 2.经常需要登陆，而且登陆经常失效，重新连接回去又要刷新。 3.只支持单向同步 群晖这个套件其实基本满足了我的需求，因为他和Moment不一样，是按照文件夹来管理图片的， 主要问题集中在分栏上，网格视图只有两栏，想快速浏览照片就非常的麻烦。 群晖SynologyPhotos DSM7.0的新APP，整合了DSPhoto与Moment，是否会带来更好的体验呢？ 如果以相册软件的角度来看，非常完美。 但是文件夹分栏依旧只有两列，还有照片模式下的管理方式来看，其实只是将两个APP重新组合到了一起。 群晖Drive 同步十分优秀，但是并不适合管理相册，UI可用，但是并不是相册。 群晖Drive以后可能会将他用到PC端的数据备份同步上，这个功能还是不错的。 PhotoPrism 棱镜相册，Web端的功能十分强大，而且具有文件夹管理功能。 但是他的APP端功能十分简陋，并没有文件夹管理的功能，只有上传，没有同步。 华芸NAS iFoto3 又需要买一台NAS么？ 看上去的功能是可以满足的，但是又需要买一台。 本地相册APP + FolderSync 1.同步功能完美满足 2.占用和服务器相同的手机空间，开销大 其实话说到这里，我突然意识到，为什么市面上的相册软件，无法满足我的需求了。 因为我的相册，并不完全是照片… 照片，截图，动漫图，表情包，长图，各种APP保存下来的各式各样的图片。 相册存储的已经不单单是照片了，而如果以只存储照片作为目标，群晖Moment是一个非常完美的解决方案， 市面上很多相册软件都能满足需求了，因为他们的自动归类和按时间存放功能，是非常优秀的。 如果可以忍受只有一行只有两张图片，那么群晖的套件已经可以满足要求了，但是作为一个安卓程序员， 还是咽不下这口气，那么，我们就来做一个满足自己所有功能的相册APP吧。 重新看一遍需求，首先想一下接下来该如何去做： 1.首先实现一个本地相册的功能，这一步相当于完成UI层的搭建，并且完成了加载，分享，操作图片等功能 2.由于PhotoPrism是开源的，接口文档也是开放的，尝试使用PhotoPrism作为服务端。完成除同步外的基本功能 3.如果还有精力，重写服务端，实现特定文件夹双向同步等功能，并支持Docker部署到NAS 虽然不是什么浩大的工程，但是这工程量依旧不小，尝试着做一下吧，万一成了呢？ PS：写完这篇文章，我想到了一个问题： 以前的图片，真的会去看么？仔细想想我确实为了一个低频功能重新开发了一个APP，真的是最好的解决方案么？ 当然好啊！我用着爽就行了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/yi-ci-android-xiang-ce-de-kai-fa-ri-zhi-ji-lu-day1/"},{"title":"一次Android相册的开发日志记录 Day2","text":"初步定好方案之后，我们先来实现一个基本的相册app。 一个基本的相册APP总共由3个页面构成： 相册文件夹页面 照片列表页 照片详情页 在页面展示之前，首先我们要能拿到数据，这里我们使用MediaStore来获取用户的媒体信息。 MediaStore记录了用户的各种类型的文件位置，并保存到数据库中名称为external.db。 权限的获取 第一步要在Manifest中申请访问媒体数据和操作本地数据的权限。 且操作本地文件的权限，在Android11以后，由于应用沙箱的限制，该权限需要动态申请。 12&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 动态获取权限 1234567public static final int PERMISSION_REQ_NO = 1234;if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { if (checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) { requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, PERMISSION_REQ_NO); return; }} 使用MediaStore获取照片信息 实际上依赖的就是我们平常用的比较少的四大组件之一，ContentProvider，这里使用的是ContentResolver来获取一个媒体的Cursor。 通过操作这个Cursor就可以获取照片信息了，看写法可以看出来，实际类似数据库的查询操作。 getContentResolver().query()他有着五个参数，分别为： 操作的URI，这里是ImageUri, MediaStore.Images.Media.EXTERNAL_CONTENT_URI QueryType，查询的数据字段，这里使用一个String数组来记录要查询的字段名，具体可以查询的字段为MediaStore.Images.Media中的常量，有需要可以点进去看看。我这里常用的几个字段如下： MediaStore.Images.Media._ID : ID MediaStore.Images.Media.DATA : 文件路径 MediaStore.Images.Media.DISPLAY_NAME : 文件名 MediaStore.Images.Media.BUCKET_DISPLAY_NAME : 相册名 MediaStore.Images.Media.BUCKET_ID : 相册ID MediaStore.Images.Media.DATE_ADDED : 添加时间 Selection，查询条件 SelectionArgs，查询条件的参数 Order，排序方式 通过query获取到Cursor之后，就可以通过ID获取index索引id去操作游标来查询数据了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void getLocalAlbum() { //sdcard下的多媒体文件 Uri uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; //查询字段 String[] queryType = new String[]{ MediaStore.Images.Media._ID, MediaStore.Images.Media.DATA, MediaStore.Images.Media.DISPLAY_NAME, MediaStore.Images.Media.BUCKET_DISPLAY_NAME, MediaStore.Images.Media.BUCKET_ID, MediaStore.Images.Media.DATE_ADDED }; //查询条件 String selection = MediaStore.Images.Media.DISPLAY_NAME + \"= ?\"; //排序 String order = MediaStore.Files.FileColumns._ID + \" DESC\"; Cursor cursor = getContentResolver().query(uri, queryType, selection, null, order); if (cursor != null) { //列Index int idIndex = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID); int dataIndex = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA); int displayNameIndex = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DISPLAY_NAME); int bucketNameIndex = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.BUCKET_DISPLAY_NAME); int bucketIdIndex = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.BUCKET_ID); int dateAddedIndex = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATE_ADDED); //循环遍历取出，直到取完 while (cursor.moveToNext()) { long id = cursor.getLong(idIndex); //Uri Uri imageUri = ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id); String path = cursor.getString(dataIndex); String displayName = cursor.getString(displayNameIndex); String bucketName = cursor.getString(bucketNameIndex); String bucketId = cursor.getString(bucketIdIndex); Integer dateAdded = cursor.getInt(dateAddedIndex); } } //记得关闭Cursor cursor.close();} 这里省略了获取照片数据后，封装和组合的操作，可以将这里的数据封装为对象，就可以在页面间传递和操作了。 这里的数据也是相册可以看到的媒体数据了。不过要注意的是URI传递需要他的对象为实现了Parcelable序列化才可传递。 如果想使用Serializable或者其他方式，可以将Uri.toString()转换为String之后再进行传递，收到后再按需parse即可。 获取了相册信息之后，就可以编写页面了。常规的RecyclerView和基础布局的设计就不在这里赘述了，说点新鲜的。 支持圆角，且宽高比固定的ImageView 参考了很多的相册APP，他们都有个共同的特典，就是每个相册是宽高比固定1:1或者其他比例。在布局中设定了占满宽度并均分之后，不同比例的图片会导致每个ImageView的高度不同，要保证宽高1:1则需要对ImageView的测量进行调整。在onMeasure里对图片进行测量并将宽高调整为相同或需要的比例。同时android:scaleType=\"centerCrop\"保证了图片会横向占满，并自动调整高度。这样显示的效果就很不错了。当按照网格排布时，宽高也是可以自适应的。 123456@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = MeasureSpec.getSize(widthMeasureSpec); setMeasuredDimension(width, width);} 为了使得页面看起来美观，我们要对图片做圆角切割。比起直接操作Bitmap会存在潜在的泄露风险，这里使用canvas的clipPath对图形进行裁剪即可。 clipPath会按照指定的路径，对图片进行裁剪遮罩，非常方便。同时可以封装为参数，对圆角的大小在布局中进行自定义的调整。 123456789101112131415161718192021222324252627282930313233343536@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); width = getWidth(); height = getHeight();}@Overrideprotected void onDraw(Canvas canvas) { //这里做下判断，只有图片的宽高大于设置的圆角距离的时候才进行裁剪 int maxLeft = Math.max(leftTopRadius, leftBottomRadius); int maxRight = Math.max(rightTopRadius, rightBottomRadius); int minWidth = maxLeft + maxRight; int maxTop = Math.max(leftTopRadius, rightTopRadius); int maxBottom = Math.max(leftBottomRadius, rightBottomRadius); int minHeight = maxTop + maxBottom; if (width &gt;= minWidth &amp;&amp; height &gt; minHeight) { //四个角：右上，右下，左下，左上 mPath.moveTo(leftTopRadius, 0); mPath.lineTo(width - rightTopRadius, 0); mPath.quadTo(width, 0, width, rightTopRadius); mPath.lineTo(width, height - rightBottomRadius); mPath.quadTo(width, height, width - rightBottomRadius, height); mPath.lineTo(leftBottomRadius, height); mPath.quadTo(0, height, 0, height - leftBottomRadius); mPath.lineTo(0, leftTopRadius); mPath.quadTo(0, 0, leftTopRadius, 0); canvas.clipPath(mPath); } super.onDraw(canvas);} 注意：clipPath如果使用硬件加速，在老设备上可能会出现显示不正常的情况。 这时可以开启setLayerType(View.LAYER_TYPE_SOFTWARE, null)来关闭硬件加速。 接下来编写的是点击相册进入的，该相册下的图片列表页。 这里依旧使用GridLayoutManager进行网格布局，讲图片按照一定列数进行排布，但是图片与图片的间隙该如何处理，我想要两侧不留白，但是图片之间还要有缝隙怎么办。这里就可以使用ItemDecoration来设置网格布局的间隔。 ItemDecoration设置间隔 123456789101112131415161718192021222324252627282930313233343536public class GridSpacingItemDecoration extends RecyclerView.ItemDecoration { private int spanCount; //列数 private int spacing; //间隔 private boolean includeEdge; //是否包含边缘 public GridSpacingItemDecoration(int spanCount, int spacing, boolean includeEdge) { this.spanCount = spanCount; this.spacing = spacing; this.includeEdge = includeEdge; } @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { //这里是关键，需要根据你有几列来判断 int position = parent.getChildAdapterPosition(view); // item position int column = position % spanCount; // item column if (includeEdge) { outRect.left = spacing - column * spacing / spanCount; // spacing - column * ((1f / spanCount) * spacing) outRect.right = (column + 1) * spacing / spanCount; // (column + 1) * ((1f / spanCount) * spacing) if (position &lt; spanCount) { // top edge outRect.top = spacing; } outRect.bottom = spacing; // item bottom } else { outRect.left = column * spacing / spanCount; // column * ((1f / spanCount) * spacing) outRect.right = spacing - (column + 1) * spacing / spanCount; // spacing - (column + 1) * ((1f / spanCount) * spacing) if (position &gt;= spanCount) { outRect.top = spacing; // item top } } }} 使用方法：为RecyclerView设置addItemDecoration即可。 12mBinding.recyclerView.addItemDecoration( new GridSpacingItemDecoration(4, DisplayUtils.dp2px(getContext(), 2.5f), false)); 好了，接下来要编写点击单个图片进入的图片详情页了。 详情页的编写 详情页最主要的就是可以放大缩小的图片View了，这里使用了比较常用的控件PhotoView。 GitHub地址为：https://github.com/Baseflow/PhotoView 按照官方的说明，进行库的添加即可，注意需要引入Jetpack源。 1implementation 'com.github.Baseflow:PhotoView:2.3.0' 全屏与沉浸模式 仔细观察我们常见的相册应用，可以发现一般相册应用都会提供点击隐藏系统UI的功能，方便用户无干扰的查看图片，这里就需要使用到全屏和沉浸模式了。 首先定义一个主题，将状态栏和导航栏的底部都设置为透明，由于预览页面底色为黑色，所以将状态栏的颜色模式设置为黑。 123456&lt;style name=\"Theme.PureGallery.ImageView\" parent=\"Theme.MaterialComponents.DayNight.NoActionBar\"&gt; &lt;!-- 其余设置略. --&gt; &lt;item name=\"android:windowTranslucentStatus\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowTranslucentNavigation\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowLightStatusBar\" tools:targetApi=\"m\"&gt;false&lt;/item&gt;&lt;/style&gt; 定义完毕主题之后，在AndroidManifest.xml文件中对Activity设置主题即可。 接下来我们可以看一下关于沉浸模式的说明，这里其实官方手册中描述的十分清楚， 参考地址：https://developer.android.com/training/system-ui/immersive 但是对于这些参数的含义可能还会有点模糊，这里记录一下。并编辑好工具类，可以在需要的时候隐藏系统UI。 View.SYSTEM_UI_FLAG_LAYOUT_STABLE：保证布局UI不会因为系统StatusBar显示隐藏发生变化，配合SYSTEM_UI_FLAG_FULLSCREEN使用 View.SYSTEM_UI_FLAG_FULLSCREEN：进入全屏模式，隐藏状态栏，高度不变 View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN：视图延伸至状态栏区域，状态栏覆盖在视图之上（等同windowTranslucentStatus） View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION：视图延伸至导航栏区域，导航栏覆盖在视图之上（等同windowTranslucentNavigation） View.SYSTEM_UI_FLAG_IMMERSIVE：沉浸模式，配合 View.SYSTEM_UI_FLAG_FULLSCREEN 和 View.SYSTEM_UI_FLAG_HIDE_NAVIGATION 一起设置 View.SYSTEM_UI_FLAG_HIDE_NAVIGATION：隐藏导航栏 1234567891011121314151617181920212223242526public class FullScreenUtils { public static void hideSystemUI(Activity activity) { // Enables regular immersive mode. // For \"lean back\" mode, remove SYSTEM_UI_FLAG_IMMERSIVE. // Or for \"sticky immersive,\" replace it with SYSTEM_UI_FLAG_IMMERSIVE_STICKY View decorView = activity.getWindow().getDecorView(); decorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN); } // Shows the system bars by removing all the flags // except for the ones that make the content appear under the system bars. public static void showSystemUI(Activity activity) { View decorView = activity.getWindow().getDecorView(); decorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION); }} 全面屏黑条问题 本来已经完美实现了要求，但是测试机是小米6，在全面屏的手机上就发现，每次在全屏模式切换下，状态栏都有一个黑条，并且布局会发生抖动。 一瞬间就想到，有可能是全面屏适配的问题，通过查询得知，就是如此。解决方法也很简单，在主题中添加一个选项即可。 1&lt;item name=\"android:windowLayoutInDisplayCutoutMode\" tools:targetApi=\"o_mr1\"&gt;shortEdges&lt;/item&gt; 参数中有三个选项，含义分别为： SHORT_EDGES：该窗口始终允许延伸到屏幕短边上的DisplayCutout区域 NEVER：窗口不允许和刘海屏重叠 DEFAULT：默认情况下，全屏窗口不会使用到刘海区域，非全屏窗口可正常使用刘海区 添加了参数选项后，黑条就消失了，布局也不会发生跳动，按照设计要求正常实现了。 经过上面这么一折腾，一个只有浏览功能的，最基础的相册APP就完成了。那么接下来需要要做什么呢，可以选择接入网络功能，或者完善本地功能。 本地相册的数据库管理 相册的创建，删除，修改 删除照片与移动照片 页面基础菜单，设置页面，导航条 分享功能，可以使用系统官方分享组件 照片的详细信息浏览，分辨率Exif等 可以考虑一下收藏功能 调用第三方播放器来播放视频 参考： https://blog.csdn.net/Grekit_Sun/article/details/114404269 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/yi-ci-android-xiang-ce-de-kai-fa-ri-zhi-ji-lu-day2/"},{"title":"一次Android相册的开发日志记录 Day3","text":"在开发阶段进入到Day2之后，工作开始变得繁忙了起来，加之生活上也有许多琐事要安排，导致相册开发进度陷入停滞。 但是与此同时，群晖的DSM7.0正式版发布了，跟随着新系统到来的，是Moments和DSPhoto两个相册软件废弃，随之而来的是整合了两者功能的SynologyPhoto， 于是我升级了并体验了一波，UI风格也与时俱进，同时整合了Moments和DSPhoto的优点，可以时间轴、文件夹、相册、多维度的管理照片，网络连接也稳定了非常多，这基本就是我想要实现的。但是还是有小遗憾的，文件夹视图模式下，仍然和DSPhoto一样，只有两列，在图片数量巨多的时候，查找就变成了一个很痛苦的事，这也是阻挠我使用这个作为相册系统的一个重要因素。 但是！等等！是不是只有这一点不满意？那么…我如果能修改一下APP，让他变成3列呢？ 说干就干，试试看。 APK解包 工具和操作步骤如下：(版本会随着时间的推移而改变，这里只取当前用到的版本) APKTool：用于解包和最后的封包 解包命令如下： 1java -jar apktool_2.6.0.jar d -s &lt;APK文件路径&gt; -o &lt;解包出的文件夹名称&gt; 这里说一下-s的指令，apk中的classes.dex文件，是讲APP代码打包编译后封装在一个或多个文件中的。 不加入-s命令，则会讲dex也进行解包操作，解出来的是smali文件，这是一种Android Dalvik虚拟机使用的一种类似汇编的语言，后面要修改代码也是修改smali文件。 如果加入-s命令，则不会解包dex文件，如果不需要对代码进行修改则基本不需要解包dex 命令执行完毕之后，就可以看到一个近似Android工程的文件夹结构，这里面有熟悉的资源文件，AndroidManifest.xml等。 直接看smali文件来修改不现实，需要一个反编译工具来帮我们定位具体要修改代码的位置。 反编译dex2jar 使用的工具是dex2jar，这个工具可以将刚才看到的classes.dex文件反编译为jar文件，但是如果代码在编译前是经过混淆的，那么这里的反编译后的代码可读性也非常的差。反编译后的代码只是用来定位修改位置，并不可以再反向编回去。 反编命令如下： 1d2j-dex2jar.bat classes.dex 执行完毕之后会出现一个classes-dex2jar.jar这样的文件，这个文件就是反编译之后的文件了。 查看反编译后的文件 jd-gui，是一个非常好用的反编译查看工具，双击打开程序，将jar拖入即可看到一个类似于IDE的界面，左边是文件结构，右侧是反编译后的代码。 具体代码就不展示了，这个APP的工程代码虽然繁杂但是目录结构十分清晰，涨知识了。由于文件夹页面是网格布局，并且代码就放在ui/folder文件夹下，很轻松就找到了，大致结构就是RecyclerView+GridLayoutManager的结构，项目自定义了一个GridLayoutManager但是可以看出来第三个参数是spanCount，找到计算spanCount的工具类Util，那么我们要修改的就是这个，让他返回一个3即可。 那么修改的操作流程就是，定位到Util的该计算方法，更改smali代码的返回值为3即可。由于我这里已经确认该函数只在这里使用了，所以可以直接修改，如果是其他修改要记得检查影响范围，避免把其他功能改崩。 dex与smali文件互转 baksmali-2.5.2.jar：将dex转换成smali文件 1java -jar baksmali-2.5.2.jar disassemble &lt;dex文件路径&gt; smali-2.5.2.jar：将smali文件打包成dex文件 1java -jar smali-2.5.2.jar assemble &lt;smali文件夹路径&gt; smali代码的修改 打开Utils.smali文件之后我们就可以找到这个计算Folder显示Colums数量的方法了，虽然说比较接近汇编的感觉，但是慢慢看还是可以理解每一步的操作。 1234567# virtual methods.method public final calculateFolderColumns(Landroid/content/Context;)I //无关代码省略 invoke-direct {p0, p1, v0, v1}, Lcom/synology/projectkailash/util/Utils;-&gt;calculateItemColumns(III)I move-result p1 return p1.end method move-result p1就是讲上方函数的计算结果赋值给p1并且返回，那么最简单的办法就是将这个p1的值，修改为3即可，不过从代码上看，这东西应该是可以适配平板的，但是不重要，我们还是改成3试试看。 具体的操作需要查阅smali是如何赋值的，操作代码如下： 1const/4 p1, 0x3 将这句代码加在return p1之前即可。 APK封包 修改好之后，需要重新打包回APK，这里依旧使用ApkTool工具： 1apktool.bat b &lt;解包的文件夹位置&gt; 运行之后，会在文件夹内部生成build和dist文件夹，dist中就是apk文件了。 重签名 这时的APK如果不进行重签名是无法安装的，签名工具有很多，也可以使用AndroidStudio带的apksigner，也可以使用第三方工具签名。 不过这里提示一句，Android11之后，仅有V1签名且targetSdk为30+的APK是无法安装，需要至少V2的签名才可以。 1apksigner sign --ks &lt;.jks文件路径&gt; --ks-key-alias &lt;jks别名&gt; --ks-pass pass:&lt;密码&gt; --v2-signing-enabled true -v --out &lt;签名后文件的路径&gt; &lt;待签名文件路径&gt; Zipalign zipalign 是一种 zip 归档文件对齐工具。它可确保归档中的所有未压缩文件相对于文件开头都是对齐的。 如果需要对齐，且使用apksigner签名，则需要在签名之前执行zipalign。 工具的位置同apksigner一样，是在sdktools下面。有些时候打包签名不成功，是因为没有进行对齐的操作，可以注意一下。 操作命令如下： 1zipalign -p -f -v 4 infile.apk outfile.apk 安装及问题排查 安装时发现报错无法安装，一直认为是签名没打对，前前后后折腾了很多次。又或是认为dex打包存在问题无法正确安装。在不修改包的情况下重签名依旧无法安装。 由于系统的报错信息语焉不详，查询问题的时候突然意识到可以使用adb安装来试着看看能不能发现报错。 结果发现了一个一直都没意识到的问题。 12adb install out.apkadb: failed to install out.apk: Failure [INSTALL_FAILED_DUPLICATE_PERMISSION: Package xxx attempting to redeclare permission com.xxx already owned by com.xxx] 由于测试机中安装了DSPhoto和群晖管家套件，这两者也使用了同样的自定义权限，但是由于我重签名后，签名不一致，所以无法安装。这里由于这两个APP已经用不到了，所以我的解决办法是直接删除这两个APP，由于DSFile并没使用此自定义权限可以共存。 如果需要共存： 1.可以修改权限名称，但需要检查是否存在潜在问题。如果需要共存可以更改包名等。 2.将这两个APK也用自己的签名重签名。 不过这点也给了我一个提示：如果无法安装出现语焉不详的问题时，可以试试使用adb来看看是否能返回具体的错误信息。 移除冲突APP之后，安装成功！！功能正常。完美的实现了我需要的功能，暂时可以不用急着写相册APP了~ MT管理器 在研究相关反编译的过程中，发现了一个非常好用的工具，MT管理器。它可以直接在手机上执行上述的操作，修改dex，重签名等而且速度也非常的快。 如果只是小部分的修改，可以直接通过这个工具来进行APK的修改，非常推荐。 后记 修改不是如文章上面一次就成功的，修改崩溃了两次，最后才找到的真正修改位置，同时也要对Android常用组件比较了解才可以做到如此快的定位到位置。 当然这里面最主要的是代码命名和分包比较规范且没有混淆，不然修改的难度就大上天了。(赞美群晖) 这就是我的第一次反编译体验，非常有趣，并且学到了很多的新知识。虽然花费了接近一天的时间，但是暂时节省了自制相册APP的开发时间(咕)。 这里面每走一步，都遇到了各种各样的问题，命令错误，解包失败，smali语法不懂，签名失败，安装失败等等等等。 但是不断的查找、重试，击破每一个问题，最后成功完成的修改，想想也是一件很不可思议且非常有成就感的事情。 工具地址与参考： APKTool：https://ibotpeaches.github.io/Apktool/install/ smali语法：https://blog.csdn.net/yuanguozhengjust/article/details/80493963 自定义权限签名问题：https://www.cnblogs.com/goodhacker/p/10082727.html https://blog.csdn.net/szu_tanglanting/article/details/43194169 MT管理器：https://www.mianshigee.com/tutorial/mt-manual/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/android/yi-ci-android-xiang-ce-de-kai-fa-ri-zhi-ji-lu-day3/"},{"title":"写在博客装修之后","text":"2018年，随着工作开始进入到正轨，总觉得要完成一些以前想要做，但是一直没有时间去做的事情， 于是，我开始尝试搭建一个属于自己的博客。 这个时候实际上已经了解了github pages，但是对于它是如何运行起来的，甚至包括博客需要一个什么样的框架， 却完全不了解。因为从来没有过搭建网站的经验，唯一的经验就是曾经在免费空间上使用Discuz安装脚本， 部署过一个论坛，其余的相关知识基本不了解。 域名，DNS，虚拟主机，Nginx，一个一个并不熟悉知识，一个一个坑过来，但是感觉这个过程还是蛮开心的。 在此期间，了解到WordPress，基于PHP的个人网站框架，研究了一下，发现扩展性非常的强， 但是插件内容的过于丰富，甚至可以说有些臃肿，并不是我理想中博客的样子。并且，部署的依赖非常的多(相对的)， 包括PHP环境，Mysql，Nginx，由于是带有后台管理的，在我对该框架非常不熟悉的情况下， 其实是比较危险的一个行为。因为我平时的学习笔记和文档都是使用Markdown编写，而在本地归档的时候， 也是一个个md文件，我想要一个和自己使用习惯比较相似的框架。 后面在了解WP备份与重新部署的步骤之后，更是让我打消了兴趣，我的目的是想要一个简洁的博客， 随带随走，只需要一个nginx即可，其余什么依赖，我都不需要。这个时候，我就发现了Hexo， 它基本完全满足了我对博客的要求。md直接的支持、基于nodejs、完全支持静态部署等， 让我觉得这是个非常优秀的框架，让我十分心动。 不过由于原始的主题太过简陋，于是开始寻找一个合适的主题，第一次找到了一个十分喜欢， 感觉接近完美的主题–matery。简单的调整，配置与修改后，博客终于开张了。 不过好景不长，在使用了一段时间之后发现，网格式的文章布局，归档的密度和分类密度过小， 并且对分类的支持并不完全符合我的需求之后，我尝试着寻找一个新的替代主题，甚至曾经想过， 自己要不要动手写一个，但是后面随着2019年更加繁忙的工作，这件事就被推迟了。由于这个主题， 没有完全达到我对于知识归档，整理收纳的需求，之后对博客的更新就暂停了。不过，虽然博客的更新进入了暂停， 但是我自己的知识文档的编写却没有停下来过。一直是在本地编写，保存在有道云笔记、印象笔记，DSNote里面。 2020年初，由于新型冠状病毒的肆虐，在家中呆了很长一段时间，萌生了再去找找看博客主题的想法，于是， 在经过一番搜索之后，发现了这个主题Icarus，相比于很多非常好看的主题，Icarus十分简洁，并且分类功能十分得我心， 多级的分类方式，更加适合知识这种需要归纳整理的文字。还有一点就是，很多非常优秀且美观的主题， 发现每一篇博文都需要一张不错的图片才能让整个主题看起来优雅，如果没有图片的时候， 当前博文的页面看起来就十分的奇怪。这并不符合我的思路，因为很多知识整理之后，图片与知识可能并没有什么关联， 并且我也没有太多的时间来弄一张图片作为该文章的头图，知识，很多时候只需要文字足以，在这一点上，Icarus做的足够好。 Hexo其实还支持评论，打赏，点赞等其他的功能，但是对于仅仅作为知识梳理与展示的博客而言， 并非需要的东西，所以我将这些暂时用不到的功能全都关闭了。不过还是打开了访问人数统计， 毕竟上一个版本的博客，并没有这个东西，我也很好奇，我写的这些文字，会不会有人看得到。想想还是蛮有趣的。 博客装修成了自己想要的样子，那么接下来，就是重新梳理知识，学习并上传到博客里面， 我觉得他可以满足我现阶段的所有需求了，也非常感谢Icarus的作者编写的这个简洁好用的博客主题。 2020注定是个不平凡的一年，虽然不知道未来会怎么样，但是我还是选择一下希望，希望新的一年， 能实现一些自我的超越吧。 2020，起航。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/daily/xie-zai-bo-ke-zhuang-xiu-zhi-hou/"},{"title":"ES6的常见知识和常用语法","text":"ES6常用语法 ES6 ECMA Script, Javascript的语言标准 提升JS编写大型的复杂的应用程序的能力(模块化) Babel: ES6 -&gt; ES5的转换器 let, const let定义变量，const定义常量 123456let r = 2;r = 4;console.log(r);---const pi = 3.14;pi = 10;//此时会报错 不能重复定义 123456var foo = 1;var foo = 2;console.log(foo); //2---let bar = 1;let bar = 2; //报错 块级作用域 1234567891011121314151617181920212223// 块级作用域if(true) { var test = 1;}console.log(test); //1---if(true) { let test1 = 2;}console.log(test1); //报错// 块级作用域2let arr = [1, 2, 3, 4];for(var i = 0, iLength = arr.length; i &lt; iLength; i++){ //do sth}console.log(i); // 4 (说明此时程序已经正确执行4次，但是这个变量i本身并不需要作为全局变量)--- let arr = [1, 2, 3, 4];for(let i = 0, iLength = arr.length; i &lt; iLength; i++){ //do sth}console.log(i); //报错 不存在变量提升 123456789console.log(foo);var foo = 1; // undefined //执行顺序var foo;console.log(foo);foo = 1;--- console.log(foo);let foo = 1; // 报错 解构赋值 数组类型的解构赋值 123456let a, b, rest;[a, b] = [1, 2]; //赋值----let a, b, rest;[a, b, ...rest] = [1, 2, 3, 4, 5, 6];//结果为 a = 1; b = 2; rest = [3,4,5,6]; 对象解构赋值 123456789101112let a, b;({ a, b} = { a: 1, b: 2}) //a = 1, b = 2----let a, b, c, rest;[a, b, c = 3] = [1, 2]; //a = 1, b = 2, c = 3 (默认值)[a, b, c] = [1, 2]; //a = 1, b = 2, c = undefined 例子：使用结构赋值做变量交换 1234567891011121314151617181920212223let a = 1;let b = 2;[a, b] = [b, a];//a = 2, b = 1----function f() { return [1, 2];}let a, b;[a, b] = f(); //a = 1, b = 2----function f() { return [1, 2, 3, 4, 5];}let a, b, c;[a, , , b] = f(); //a = 1,b = 4----function f() { return [1, 2, 3, 4, 5];}let a, b, c;[a, ...b] = f(); //a = 1,b = [2,3,4,5][a, , ...b] = f(); //a = 1,b = [3,4,5] 例子：对象结构赋值 123456789101112131415161718192021222324252627282930//对象解构赋值let o = { p: 42, q: true};let { p, q} = o;console.log(p, q); // 42 true----let { a = 10, b = 5} = { a: 3}; //a = 3, b = 5----let metaData = { title: 'abc', test: [{ title: 'test', desc: 'desc' }]}let { title: esTitle, test: [{ title: cnTitle }]} = metaData; //abc, test 箭头函数 参数 =&gt; 表达式/语句 1234567let value = 2;let double = x =&gt; 2 * x;let treble = x =&gt; { return 3 * x;}console.log('double: ', double(value)); //4console.log('treble: ', treble(value)); //6 继承外层作用域(没有独立作用域) 12345678910var obj = { commonFn: function(){ console.log(this); }, arrowFn: () =&gt; { console.log(this); }}obj.commonFn(); //this 指向obj作用域obj.arrowFn(); //this 指向了obj所在作用域，window 不能用作构造函数 12345let Ani = function(){}let ani = new Ani(); //OK---let Ani = () =&gt; {}let ani = new Ani(); //报错 没有prototype属性 12345let commonFn = function(){};let arrowFn = () =&gt; {};console.log(commonFn.prototype); //constructorconsole.log(arrowFn.prototype); //undefined 模板字符串 反引号标识 `` 支持多行字符串 1234567//基本用法let str = `&lt;div&gt; &lt;h1 class=\"title\"&gt;Test&lt;/h1&gt;&lt;/div&gt;`;document.querySelector('body').innerHTML = str; //在body中显示字符串 支持变量和表达式 123456789101112131415161718192021222324252627282930//嵌套变量的用法let name = 'Jmeow';let str = `&lt;div&gt; &lt;h1 class=\"title\"&gt;${name}&lt;/h1&gt;&lt;/div&gt;`;document.querySelector('body').innerHTML = str;//嵌套函数的用法let getName = () =&gt; { return 'Jmeow Test';};let str = `&lt;div&gt; &lt;h1 class=\"title\"&gt;${getName()}&lt;/h1&gt;&lt;/div&gt;`;document.querySelector('body').innerHTML = str;//循环嵌套let names = ['AA', 'BB', 'CC'];let str=` &lt;ul&gt; ${ names.map(name =&gt; `&lt;li&gt;Hi, I am ${name}&lt;/li&gt;`).join('') } &lt;/ul&gt;`;document.querySelector('body').innerHTML = str; Promise对象 Promise关键词： resolve 预期结果正确 reject 预期结果失败 then 1234567891011121314151617181920//Promise结构new Promise((resolve, reject) =&gt; { //异步函数 $.ajax({ url: 'http://z.cn/user/get_user_info.do', type: 'post', success(res){ resolve(res); }, error(err){ reject(err); } });}).then((res) =&gt; { //resolve console.log('success:', res);},(err) =&gt; { //reject console.log('success:', err);}); 在没有使用Promise之前 12345678910111213141516171819$.ajax({ url: 'http://z.cn/user/get_user_info.do', type: 'post', success(res){ $.ajax({ url: 'http://z.cn/user/get_count.do', type: 'get', success(res){ resolve(res); }, error(err){ reject(err); } }); }, error(err){ //err }}); 使用Promise的链式请求 12345678910111213141516171819202122232425262728293031323334var promiseFn1 = new Promise((resolve, reject) =&gt; { //异步函数 $.ajax({ url: 'http://z.cn/user/get_user_info.do', type: 'post', success(res){ resolve(res); }, error(err){ reject(err); } });});var promiseFn2 = new Promise((resolve, reject) =&gt; { //异步函数 $.ajax({ url: 'http://z.cn/user/get_count.do', type: 'get', success(res){ resolve(res); }, error(err){ reject(err); } });});promiseFn1.then(() =&gt; { //success console.log('promiseFn1 success'); return promiseFn2;}).then(() =&gt; { console.log('promiseFn2 success');}); 面向对象 类 关键词：class 语法糖 -&gt; 对应function 构造函数，constructor 1234567891011class Animal{ constructor(age){ this.name = 'ani'; this.age = age; } getName(){ return this.name + this.age; }}let animal = new Animal('20');console.log(animal.getName()); //ani20 类的继承 extends 类的继承 super 调用父类的构造函数 1234567891011121314151617181920//类的继承class Animal{ constructor(){ this.name = 'ani'; } getName(){ return this.name; }}//extends后是没有this关键字的，如需要使用，需要使用super()class Cat extends Animal{ constructor(){ super(); this.name = 'cat'; }}let animal = new Animal();let cat = new Cat();console.log(animal.getName());console.log(cat.getName()); 对象 对象里属性的简写 对象里方法的简写 属性名可以为表达式 其他扩展 1234567891011121314151617181920212223242526272829303132333435//对象的用法//ES旧语法var name = 'Jmeow'; age = 18;var obj = { name: name, age: age, getName: function(){ return this.name; }, getAge: function(){ return this.age; }}// ES6语法let name = 'Jmeow', age = 18;let obj = { //变量名可以直接用作对象的属性名称 name, age, //对象里的方法可以简写 getName(){ return this.name; }, //表达式作为属性名或方法名 ['get' + 'Age'](){ return this.age; }}//Object对象的扩展Object.keys(obj);Object.assign({a:1},{b:2}); // {a:1 ,b:2}Object.assign({a:1},{a:2, b:2}); // {a:2 ,b:2} ES6模块化 解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程 CommonJS, AMD, CMD index.js 12345678910111213import { str as string, obj, fn} from './module.js';import foo from './module.js';console.log('name:', obj.name);// console.log('str:', str);console.log('string:', string);console.log('fn:', fn);console.log(foo); module.js 12345678910111213let str = 'string';let obj = { name: 'Jmeow'};let fn = () =&gt; { console.log('module test');};export { str, obj, fn}export default {a:1} index.html 1&lt;script type=\"module\" src=\"./index.js\"&gt;&lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/frontend/javascript/es6-de-chang-jian-zhi-shi-he-chang-yong-yu-fa/"},{"title":"前端本地存储相关使用方式","text":"Cookie 用户端保存请求信息的机制 分号分隔的多个key-value字段 存储在本地的加密文件里 域名和路径限制 字段： name：cookie名称 domain：cookie生效的域名 path：cookie生效的路径 expires：cookie过期时间 HttpOnly：用户端不可更改 Session 服务端保存请求信息的机制 sessionId通常存放在cookie里 会话由浏览器控制，会话结束，session失效 12345678//查看当前domain的cookiedocument.cookie;//添加cookievar d = new Date();let str = d.toUTCString();//expires时间不可过期document.cookie = \"name=Jmeow;domain=jmeow.org;path=/index.html;expires=\" + str;//删除cookie，过期时间设置为0即可 LocalStorage 本地存储 H5新特性 有域名限制，不存在作用域概念 只有key-value 没有过期时间 浏览器关闭后不会消失 12345678910//添加localStoragewindow.localStorage.setItem('name','Jmeow');//查看localStoragewindow.localStorage.getItem('name');//删除localStoragewindow.localStorage.removeItem('name');//如果需要存储一个对象，需要转换JSON.stringify()window.localStorage.setItem('name',JSON.stringify({name: 'Jmeow'})); SessionStorage 和localStorage相似 会话结束后会消失 12//添加sessionStoragewindow.sessionStorage.setItem('name','Jmeow'); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/frontend/javascript/qian-duan-ben-di-cun-chu-xiang-guan-shi-yong-fang-shi/"},{"title":"网络相关基础知识","text":"页面加载过程 URL解析 DNS查询 资源请求 浏览器解析 URL结构 12http://www.baidu.com:80/getdata.do?userId=1#title协议 域名 端口 路径 参数 哈希 DNS查询 DNS全称：Domain Name System 浏览器 -&gt; DNS缓存 -&gt; DNS服务器 dns-prefetch 资源请求流程 浏览器 -&gt; 后端服务器 Request-header + 参数(url body) status + Response-header + body 浏览器解析(理想环境) DOM + JS执行(如出现JS，暂停DOM构建，先执行JS) 构建渲染树 布局(确定元素大小和位置) 绘制 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/frontend/wang-luo-xiang-guan-ji-chu-zhi-shi/"},{"title":"HTML5 CSS 基础知识","text":"HTML HTML常见元素 header (一些资源和信息描述) meta title style link script base body div/section/article/aside/header/footer p span/em/strong table/thead/tbody/tr/td ul/ol/li/dl/dt/dd a form/input/select/textarea/button 元素的常见使用 视口：宽度为设备宽度，初始化缩放比例1，最大缩放比例1，用户不可缩放 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"&gt; 指定基础路径 1&lt;base href=\"/\"&gt; HTML标签常见属性 a href 地址 target 打开位置 self / blank img src 图片地址 alt 当src不可用时的替换资源 table td colspan 占据几行 (近似效果-合并单元格) rowspan 占据几列 form target 表单提交的地址 method 表单提交的方法 GET POST enctype 编码方式 url-encode form-data input type value button type select | option value label 与表单相关联 for HTML5新增内容 新区块标签 section 区块 article 区块 nav 导航 aside 不重要内容(广告) HTML元素分类 按默认元素分 块级 block会占整行 div section article aside 行内 inline span em strong inline-block 对内block，对外inline input 按内容分 content model HTML元素嵌套关系 块级元素可以包含行内元素 块级元素不一定能包含块级元素 行内元素一般不能包含块级元素 a可以包含块级元素 常见问题 doctype的作用 让浏览器以标准模式渲染 让浏览器知道元素的合法性 HTML XHTML HTML5 的关系 HTML属于SGML XHTML属于XML，是HTML进行XML严格化的结果 HTML5不属于SGML，XML，比XHTML宽松 HTML5的变化 新的语义化元素 表单增强 新的API(离线，音视频，图形，实时通讯，本地存储，设备能力) 分类和嵌套变更 em和i的区别 em是语义化的标签，表示强调 i是纯样式的标签，表示斜体 HTML5中i不推荐使用，一般使用做图标 语义化的意义是什么 开发者容易理解 机器容易理解结构(搜索、读屏软件) 有助于SEO semantic microdata 哪些元素可以自闭合 表单元素 input 图片 img br hr meta link HTML和DOM的关系 HTML是死的 DOM由HTML解析而来，是活的 JS可以维护DOM property和attribute的区别 attribute是死的，写在html元素中的 property是活的 form的作用有哪些 直接提交表单 使用submit/reset按钮 便于浏览器保存表单 第三方库可以整体提取值 第三方库可以进行表单验证 CSS基础 CSS全称：Cascading Style Sheet 层叠样式表 基本规则 选择器 用于匹配HTML元素 有不同的匹配规则 多个选择器可以叠加 Tips：浏览器对css的解析方式：从右往左进行解析，提高解析速度与效率。 1234选择器{ 属性: 值; 属性: 值;} 选择器分类 元素选择器 a{} 伪元素选择器 ::before{} 类选择器 .link{} 属性选择器 [type = radio]{} 伪类选择器 :hover{} ID选择器 #id{} 组合选择器 [type = checkbox] + label{} 否定选择器 :not(.link){} 通用选择器 *{} 选择器权重 选择器本身的权重 ID选择器 #id{} +100 类 属性 伪类 +10 元素 伪元素 +1 其他选择器 +0 特殊权重规则 !important 优先级最高 元素属性 优先级高 &lt; style &gt; 相同权重 后写的生效 非布局样式 字体，自重，颜色，大小，行高 背景，边框 滚动，换行 粗体，斜体，下划线 其他 字体 字体族 衬线字体 serif 非衬线字体 sans-serif 等宽字体 monospace 手写体 cursive 花体 fantasy 多字体fallback 微软雅黑 &gt; 黑体 &gt; 非衬线字体 iconfont 字体图标 原理：自定义字体，利用伪元素 行高 行高的调整 vertical-align 图片3px缝隙问题： inline元素，与字体大小相关，base-line和底线对其方式不同。 解决方式： vertical-align: bottom display: block 背景 背景颜色 background: red rgb hsl(0,100,100%) rgba,hsla (a为透明度) url(’./a,jpg’) 背景图 渐变色背景 \"-webkit-linear-gradient(left,red,green)\" 从左到右，红色渐变为绿色 \"linear-gradient(to right,red,green)\" 从左到右，红色渐变为绿色 \"linear-gradient(45deg,red 0,green 10%, yellow 50%, blue 20%)\" 45度角渐变 背景图片和属性(雪碧图) 用于性能优化 background-repeat: no-repeat/repeat-x/repeat-y; 不平铺/x方向平铺/y方向平铺(默认平铺) background-position: center top; 指定位置 background-position: 20px 30px; 指定位置 background-size: 100px 50px; //指定背景图大小 base64和性能优化: 一般用于小图标小图片，因为base64转换也需要消耗性能 边框 边框的属性：线形 大小 颜色 border 1px solid red //1px边框 实线 红色 dotted //点状 dashed //虚线 边框背景图 border: 30px solid transparent; border-image: url(./a.png) 30px repeat/round; 边框衔接(三角形) border-bottom: 30px solid red; border-right: 30px solid transparent; 滚动 overflow 滚动行为和滚动条 visible 超出容器部分显示，滚动条隐藏 hidden 超出容器部分隐藏，滚动条隐藏 scroll 超出容器部分允许用户滚动，滚动条一直显示 auto 超出容器部分允许用户滚动，滚动条自动显示 文字折行 overflow-wrap(word-wrap)通用换行控制 是否保留单词 word-break 针对多字节文字 中文句子也是/不是单词 white-space 空白处是否断行 装饰性属性及其他 字重（粗体）font-weight normal bold bolder lighter 100 斜体 font-style:itatic 下划线 text-decoration 指针 cursor 补充：美化checkbox label[for]和id 隐藏原生input :checked + label CSS布局 table 表格布局 123.table{ display: table;} float浮动 + margin inline-block 布局 flexbox布局 position static 静态默认 relative 偏移，不会改变原始占有空间 left top absolute 脱离了整个文档流,不会对其他元素造成影响,相对于body布局 left top fixed 脱离了整个文档流,不会对其他元素造成影响,相对于屏幕 left top document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/frontend/css/html5-css-ji-chu-zhi-shi/"},{"title":"Mac下禁用Chrome跨域检查","text":"在开发时，我们经常会遇到CORS跨域问题，这是由于浏览器的同源策略，这是一种浏览器的安全限制。 但是在本地前后端分离式开发的时候，经常会遇到要本地浏览器调用非同源请求，这个时候可以对后端进行CORS的处理。 但是有时候，出现跨域问题，只是临时开发时才会出现的问题。 那么我们可以暂时关闭浏览器的跨域检查，来简化我们的开发。 需要创建一个存放临时配置文件的目录 这里我们在当前用户目录下创建一个名为tmp的文件夹 1mkdir tmp 在终端中输入以下命令，注意，这里面的user-data-dir需要换成你刚才创建的临时目录 1open -n -a /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --args --user-data-dir=\"/Users/&lt;用户名&gt;/tmp\" --disable-web-security 接下来执行即可，Chrome会提示安全检查已关闭，此时的浏览器最好只用于开发环境下对接口进行测试。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/frontend/mac-xia-jin-yong-chrome-kua-yu-jian-cha/"},{"title":"webpack-dev-server配置翻车记录","text":"在配置WebpackDevServer后，在开发的过程中，经常出现莫名其妙的内存溢出，最后经过多方排查，发现问题出在webpack的配置文件上。 错误的配置文件 1234567891011121314151617181920//旧配置文件，现作废，原因见下面描述devServer: { //基础目录(可选) //contentBase: './', //如果需要被外部访问 host: \"0.0.0.0\", port: 8989, //只显示错误提示 stats: \"errors-only\", //静态资源路径 publicPath: \"/dist/\", //在devServer启动之前执行的方法 after: () =&gt; { console.log('Server Start!'); }, //将默认 /dist/ 路径代理为 / 路径 proxy: { '/': 'http://0.0.0.0:8989/dist/' }} 正确的配置文件 12345678910111213141516//正确配置文件devServer: { //如果需要被外部访问 host: \"0.0.0.0\", port: 8989, //只显示错误提示 stats: \"errors-only\", //devserver资源路径，默认\"/\" //提示，如果没有配置这里的publicPath，但是配置了output.publicPath //这里的publicPath会默认为output.publicPath中配置的，而不是\"/\" publicPath: \"/\", //在devServer启动之前执行的方法 after: () =&gt; { console.log('Server Start!'); }} 乱用proxy代理会产生递归查找的bug 如果页面调用了一个不存在的资源，就会出现路径fe/dist/dist/dist/dist/dist/dist/bg2.png 这里的dist会无限延伸下去，直到爆内存。 MemoryFS库会因为读取了一个超大的string导致1.4G默认内存被占满，devserver因此而崩溃。这就是因为使用了错误的代理导致的。 1234567891011module.exports = { output: { path: path.resolve(__dirname, 'dist'),- publicPath: '/dist/', filename: 'js/app.js' }};//将默认 /dist/ 路径代理为 / 路径- proxy: {- '/': 'http://0.0.0.0:8989/dist/'- } 问题原因 解决这个问题其实也很简单，就是搞清楚webpack这几个路径究竟是什么意思。 在网上查到的很多资料，大多语焉不详，很难说清楚具体的区别。有的说的过于高深又很难理解。 如果这几个路径配置有问题，就会出现无法访问静态资源，页面无法加载等问题。 output.publicPath 会在所有loader生成的路径前，加入一个前缀 如果publicPath: /dist/ 那么所有loader生成的路径前会变成，/dist/res/a.jpg devServer.publicPath 默认为\"/\"，但是如果output.publicPath配置了路径，那么会使用output.publicPath中的路径。 提示：这里面的前提是，devServer.publicPath不去配置，使用默认值的情况。 如果你配置了默认值，devServer回去选择只用你在devServer下面配置的这个路径。 这句话是在webpack官网中output部分，而不是在devserver部分。 因为这个说明绕了很大的弯路。 contentBase 指定静态服务器的根目录，可以访问到不通过webpack处理的文件。 感想 经过这趟折腾，虽然绕了一圈回到了起点，发现起点的内容就是正确的。 本意是想让devserver默认/路径即可访问资源，而不是使用url/dist/访问。实际上导致这个问题的，是output里的publicPath。 绕了好大的一个圈，终于绕明白了，也让我了解到，这几个参数的具体含义，在这里也要感谢这位博主，把这几个路径说的十分明白。 至于之前在网络上为什么没有搜到，将/dist/ 切换到/ 作为默认根路径的做法。答案就很简单了，因为，本来默认就是/作为根路径。只是我设置错了，才导致的这个错误，那么再改回去就好了，自然也就很难搜索到结果了。 这里也是多亏了观察，删掉devserver路径之后，观察了下network，发现index被找到了，那么资源文件没找到的原因，就容易定位了。 从2月17日埋藏下的隐形bug，因为这次内存溢出发现了真实的原因，也是可喜可贺。 参考博客 https://blog.csdn.net/fengmin_w/article/details/81984514 https://blog.csdn.net/lhjuejiang/article/details/80243975 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/frontend/webpack-dev-server-pei-zhi-fan-che-ji-lu/"},{"title":"Python基础知识","text":"数据类型 1234567891011121314# 除求整数print(2//2)# 除小数print(2/2)# python 表示二进制 在数字后面加 0b# 0b10 表示二进制的10print(0b10)# python 表示八进制 在数字后面加 0o# 0o10 表示八进制的10print(0o10)# python 表示十六进制 在数字后面加 0x# 0x10 表示十六进制的10print(0x10)print(0x1F) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#=======进制转换=======#将其他进制数转换为2进制print(bin(10))print(bin(0o7))print(bin(0xE))# 将其他进制数转换为8进制print(oct(888))print(oct(0x7777))print(oct(0b111))# 将其他进制数转换为10进制print(int(0b111))print(int(0o77))print(int(0x11E))# 将其他进制数转换为16进制print(hex(888))print(hex(0o7777))print(hex(0b111))#bool：类型print(type(True))print(type(False))# bool True Falseprint(bool('abc'))print(bool(''))print(bool([]))print(bool([1,2,3]))# 表示复数 complexprint(36j)# 转义字符print('let\\'s go')# 换行print(\"\"\"hello\\nhello\"\"\")# 字符串拼接print(\"hello\"+\"world\")# 字符串计算print(\"hello\" * 3)# 字符串索引(负数为反向查找)print(\"hello\"[0])print(\"hello\"[3])print(\"hello\"[-1])# 字符串截取print(\"hello world\"[0:5])print(\"hello world\"[0:-1])print(\"hello world\"[6:11])# 原始字符串print(r'C:\\Windows')print(R'C:\\Windows') 数组元组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 列表类型 listprint(type([1,2,3,4,5,6]))print(type([\"AA\",\"BB\",2,3,True,False]))# 二维数组print(type([[1,2],[3,4]]))# 数组操作# 使用[]来进行操作，取出的会是字符串，使用[:]进行操作，取出的会是数组print([\"A\",\"B\",\"C\"][0])print([\"A\",\"B\",\"C\"][2])print([\"A\",\"B\",\"C\"][0:2])print([\"A\",\"B\",\"C\"][-1:])print([\"A\",\"B\"] * 3)# 元组print(type((1,2,3)))print(type((1,2,False)))print((1,2,False)[2])# int str list# inprint(3 in [1,2,3,4,5])print(6 in [1,2,3,4,5])print(6 not in [1,2,3,4,5])# 长度操作 lenprint(len(\"HELLO !\"))# 最大最小值 max minprint(max([1,2,3,4,5]))print(min([1,2,3,4,5]))print(min(\"hello\"))# ASICII码 ordprint(ord('w'))print(ord(\" \"))# 集合 set 特点：无序，不重复print({1,2,3,4,4,5})print({1,2,3,4,5})print({6,2,2,3,4,5})# 集合不可通过以下方式操作，因为集合无序# print({6,2,2,3,4,5}[0])print(len({1,2,3}))print(1 in {1,2,3})print(1 not in {1,2,3})# 集合的操作# 求两个集合的差集print({2,3,4,5} - {5,6})# 求交集print({2,3,4,5,6} &amp; {5,6,7,8})# 求并集print({2,3,4,5,6} | {5,6,7,8})# typeprint(type({}))print(type(set()))# dict 字典类型 Key Value 不可以有重复key，重复会被覆盖# {key1:value1, key2:value2}print(type({\"AA\":\"aa\", \"BB\":\"bb\"}))# 寻找dict中keyprint({\"A\":\"张\",\"B\":\"王\",\"C\":\"李\",\"D\":\"赵\"}[\"A\"]) 变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273print([1,2,3,4,5] * 3 + [1,2,3] + [1,2,3,4,5])# 变量A = [1,2,3,4,5]B = [1,2,3]print(A * 3 + B + A)# 变量命名规则： 数字，字母，下划线，区分大小写# 保留关键字： and in if importa_b_c = 1d433a = '你好'a_b_c = {1,2,3}# 变量名会覆盖方法名# type = 1# print(type)# int str tuple (不可变)值类型 list set dict(可变) 引用类型a = [1,2,3]b = aa[0] = '1'print(b)# 字符串a1 = 'Hello'a1 = a1 + 'World'print(a1)# id 显示内存地址print(hex(id(a1)))a1 = a1 + 'AAS'print(a1)print(hex(id(a1)))b1 = \"aaa\"print(id(b1))b1 = b1 + \"bbb\"print(id(b1))# 添加元素[] , ()元组不可变A3 = [1,2,3]A3.append(4)print(A3)# 查找元素B1 = (1,2,3,[1,4,5,['b','n','m']])print(B1[3][3][1])# 虽然元组不可变，但是元组中的列表可变B1[3][3][1] = 'K'print(B1[3][3][1])# 运算符 //整除 %取余 **乘方# 比较 and or notprint('abc' == 'abc')print(True and False)print(True or False)print(not True)# 成员运算符 in not inG1 = [1,3,4,5]print(2 in G1)print(2 not in G1)print('2' in G1)# 只取keyG2 = 1print(G2 in {'d':1})G2 = 'd'print(G2 in {'d':1})# 身份运算：F1 = 1F2 = 1.0print(F1 == F2) # 比较数值相等print(F1 is F2) # 比较两个变量的身份是否相等D1 = 2D2 = 2print(id(D1))print(id(D2))# 判断变量类型D3 = 10print(type(D3) == int)print(isinstance(D3,int))print(isinstance(D3,float))print(isinstance(D3,(int,float))) 分支判断 12345678910111213141516171819202122232425262728293031323334353637383940# 这是单行注释'''这是多行注释'''e = 1if e == 1: print(1)else: print(2)# 简单判断测试account = 'AAA'pwd = '111'user_account = input()user_pwd = input()# 逻辑运算符 优先级最低if account == user_account and pwd == user_pwd: print('YES')else: print('NO')# constant 常量# Python 中不存在常量，但是规定常量的写法为：变量名大写# ACCOUNT = 'AAA'if True: pass # 空语句 占位语句# elif -&gt; else ifif True: passelif pwd == 1: passelse: pass# input -&gt; type 'str'ty = input()print(type(ty))A1 = 1A2 = 8print(A1 or A2) 循环 1234567891011121314151617181920212223242526# 循环# whilecounter = 1while counter &lt;= 10: counter += 1 print(counter)else: print('END')# for 遍历，循环，序列或集合字典lista = [1,2,3,4,5]for list_a in lista: # 遍历 print(list_a)listb = [[1,2,3,4,5],('a','b','b')]for x in listb: for y in x: print(y) # break 中断循环else: print('aaa')# 重复指定次数代码循环for x in range(0,10): # for(int i = 0; i &lt; 10; i++) print(x)for x in range(0,10,2): # 2 ：间隔 print(x,end=' | ')for x in range(10,0,-2): # 递减 print(x,end=' | ') document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/other/python-ji-chu-zhi-shi/"},{"title":"关于软件更新那些事","text":"作为一个程序员，与时俱进是非常重要的，学习新知识，新技术，是保持自己竞争力的重要途径。但是在生产开发环境中，保持开发环境的稳定，又是对整个项目来说，非常重要的一环，随意的升级项目依赖版本，很有可能会引入各种隐性问题，轻则导致项目无法启动，重则出现生产事故。 但是真的完全因为稳定，就不进行任何升级了么？这也未必。最开始我也是坚定的不升级派：只要不变，就不会出错。无论是开发环境，还是日常的使用环境，都保持非必要不更新。 但是随着开发的继续，与日常生活中的一些体会，让我对看待这件事情的态度，变的更加的灵活与客观了。 这篇文章并非是说一定要对软件与环境进行更新，或是一定不要更新，只是总结了一些在开发与生活中遇到的事情与感悟。 为什么不更新 1.提高效率，聚焦核心内容，不要被细枝末节打扰 2.保持环境稳定，避免引入问题 3.更新很多时候是不必要的，引入了很多无用的东西。 4.增加学习成本， AndroidX适配与WebViewBUG Android Studio 4.1 升级到 2020.3.1 甚至看不懂新的Gradle参数，Kotlin与JetpackCompose 公司更换新笔记本电脑，Snipaste旧版本无法使用 Windows11？ 时隔许久再次打开MacBook 总结 1.对日常生活用的软件，仍旧非必要不更新 2.对开发用的软件，待版本逐渐稳定后开始尝试更新与迁移 3.保持对新技术的敏感性，是否要学习可以动态调整 4.如果现有的生产依赖已经存在问题，不要犹豫，不要绕过问题，直面问题去更新，避免问题堆积。 5.如果已经是不稳定的环境了，可以尝试更新。 6.不稳定的东西不要用在生产，可以测试使用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/other/guan-yu-ruan-jian-geng-xin-na-xie-shi/"},{"title":"算法","text":"冒泡排序 123456789101112131415161718192021222324252627282930/** * Created by Neko~ on 2017/4/10. */public class alg1 { private static int[] data={9,16,27,23,30,49,21,35}; public static void bubbleSort(){ System.out.println(\"开始排序\"); int arraylength = data.length; for(int i = 0; i&lt;arraylength-1; i++){ //-1的原因是最大的数不用排了 boolean flag = false; //用于记录数组是否进行了排序，如果为false说明数组是按数字大小顺序排列的 for (int j = 0; j &lt; arraylength-1 -i ;j++){//-1-i是因为这些数已经排好放在最后了，不用再排序 if (data[j] - data[j+1] &gt; 0){ //如果前面的数比后面的数大，交换 int tmp = data[j + 1]; data[j + 1] = data [j]; data[j] = tmp; flag = true; } } System.out.println(java.util.Arrays.toString(data)); if(!flag){ System.out.println(\"没有进行排序\"); } } } public static void main(String[] args) { bubbleSort(); }} 快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Created by Neko~ on 2017/4/10. * * 快速排序 */public class alg2 { public static void main(String[] args) { int[] nums = {49,38,65,97,76,13,27}; //使用 快速排序方法 quickSort(nums, 0, nums.length-1); //显示排序之后的数组 System.out.println(java.util.Arrays.toString(nums)); } //data:要进行排序的数组 //start:选取的第一个数，作为索引号，在这里就是49，用这个数和其他数进行比较 //end:最后一个元素，这里是索引号，27 public static void quickSort(int[] data,int start ,int end){ int i = start;//相当于i,左索引 int j = end;//相当于j,右索引 if(i &gt;= j){//判断索引到达中间 //此处的return是每个递归的退出条件，之后退出 return; } //设置指针方向的逻辑变量，就是从左搜索还是从右搜索 boolean flag = true;//false：从左至右 true：从右至左 while (i!=j){ //如果i=j证明第一次排序结束，每次的标准值只是一个，比如第一波的比较值是49 if(data[i] &gt;data[j]){ //交换数字 //所有比它小的数据元素一律放到左边，所有比它大的数据一律放到右边 int temp = data[i]; data[i] = data[j]; data[j] = temp; //数据交换后才可以将游标的移动位置改变 //交换之后，游标就需要改变了 flag = (flag ==true) ? false : true ; } //将指针向前或者向后移动，第一次从左向右，第二次从右向左 if(flag) {//true 右--》向左 j--; }else{//false 左--》向右 i++; } } //到此，数组的数据排列位置为： //第一次到该位置，data的值为：[27,38,13,49,76,97,65] //将数组分开两半，确定每个数字的正确位置 //i=3 j=3 i--; j++; //i=2 j=4 start=0 end=6 //也就是说中间的49被分割出来，这个49其实是已经排好位置的数字了 //进行递归操作 quickSort(data,start,i);//也就是27 38 13的快速排序 quickSort(data,j,end);//也就是76 97 65的快速排序 }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/algorithm/suan-fa/"},{"title":"JavaBasic-final关键字","text":"关于final关键字 final的优点： final提高了性能，JVM和Java应用都会缓存final变量。 final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。 使用final关键字，JVM会对方法变量及类进行优化。 关于final的重要知识点 final关键字可以用于成员变量、本地变量、方法以及类。 final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。 你不能够对final变量再次赋值。 本地变量必须在声明时赋值。 在匿名类中所有变量都必须是final变量。 final方法不能被重写。 final类不能被继承。 final关键字不同于finally关键字，后者用于异常处理。 final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。 接口中声明的所有变量本身是final的。 final和abstract这两个关键字是反相关的，final类就不可能是abstract的。 final方法在编译阶段绑定，称为静态绑定(static binding)。 没有在声明时初始化final变量的称为空白final变量(blank final variable) 它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。 按照Java代码惯例，final变量就是常量，而且通常常量名要大写： Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Created by Neko on 2017/11/9. */public class Demo1 { //TODO 1 //final可以声明成员变量、方法、类以及本地变量。 //一旦你将引用声明作final，你将不能改变这个引用。 public static final String NAME = \"Name\"; public static void main(String[] args) { //NAME = new String(\"name\"); //报错，因为final变量是只读的 } //TODO 2 class PersonalLoan{ public final String getName(){ return \"personal loan\"; } } class CheapPersonalLoan extends PersonalLoan{ //final 代表这个方法不可以被子类的方法重写 /*@Override public final String getName(){ }*/ } //TODO 3 //使用final来修饰的类叫做final类。final类通常功能是完整的，他们不能被继承。 final class PersonAA{ } //报错 不可以被继承 /*class CheapPersonAA extends PersonAA{ }*/ //TODO 4 //对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容 private final List Loans = new ArrayList(); public void add(){ Loans.add(\"home loan\"); Loans.add(\"personal loan\"); //Loans = new Vector();//报错 不允许 }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/basic/javabasic-final-guan-jian-zi/"},{"title":"UDP与JavaUDP操作","text":"UDP是什么 全称 User Datagram Protocol 一种用户数据报协议，又称用户数据报文协议 是一个简单的面向数据报的传输层协议，正式规范为RFC 768 用户数据协议、非连接协议 UDP为什么不可靠 它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份 UDP在IP数据报的头部，仅仅加入了复用和数据校验（字段） 发送端生产数据，接收端从网络中抓取数据 结构简单、无校验、速度快、容易丢包、可广播 UDP能做什么 DNS TFTP SNMP 视频、音频、普通无关紧要数据 UDP报文头 两组0-32，一共64为bit 第一组 0-15 Source Port 发送端口号 16-31 Destination Port 接受端口号 第二组 0-15 Length 长度 16-31 Header and Data Checksum 头部和数据校验 UDP包最大长度 16位-&gt;2字节 存储长度信息 2^16-1 = 64K - 1 = 65536 - 1 = 65535 自身协议占用：32+32位 = 64位 = 8字节 65535 - 8 = 65507 byte Java UDP API DatagramSocket 作用 用于接收与发送UDP的类, 负责发送某一个UDP包，或者接受UDP包 不同于TCP，UDP并没有合并到SocketAPI中 API DatagramSocket() 创建简单实例，不指定端口与IP DatagramSocket(int port) 创建监听固定端口的实例 DatagramSocket(int port, InetAdderss loaclAddr)创建固定端口指定IP的实例，当本地存在多个IP的情况下 receive(DatagramPacket d) 接受 send(DatagramPacket d) 发送 setSoTimeout(int timeout) 设置超时，毫秒 close() 关闭、释放资源 DatagramPacket 作用 用于处理报文 将byte数组、目标地址、目标端口等数据包装成报文或者将报文拆卸成byte数组 是UDP的发送实体，也是接收实体 API DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port) 前面3个参数指定buf的使用区间 后面2个参数指定目标机器地址与端口 DatagramPacket(byte[] buf, int length, SocketAddress address) 前面3个参数指定buf的使用区间 SocketAddress相当于InetAddress + Port setData(byte[] buf, int offset, int length) setData(byte[] buf) setLength(int length) setAddress(InetAddress iaddr) setPort(int iport) setSocketAddress(SocketAddress address) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/basic/udp-yu-javaudp-cao-zuo/"},{"title":"JavaBasic-ThreadLocal","text":"ThreadLocal ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这个时候该变量是多个线程共享的。 ThreadLocal中，会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。 Demo1 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Created by Neko on 2017/11/9. */public class ThreadL1 { //通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值 private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;(){ public Integer initialValue(){ return 0; } }; //获取下一个序列值 public int getNextNum(){ System.out.println(\"____\"+seqNum.get()); seqNum.set(seqNum.get()+1); return seqNum.get(); } public static void main(String[] args) { ThreadL1 tl = new ThreadL1(); //三个线程共享tl，各自产生序列号 TestClient t1 = new TestClient(tl); TestClient t2 = new TestClient(tl); TestClient t3 = new TestClient(tl); t1.start(); t2.start(); t3.start(); } private static class TestClient extends Thread{ private ThreadL1 tl; public TestClient(ThreadL1 tl){ this.tl = tl; } public void run(){ for (int i = 0; i&lt;3 ;i++){ //每个线程打出3个序列值 //currentThread()获取当前运行的线程对象 System.out.println(\"Thread[\"+Thread.currentThread().getName()+\"]---&gt;tl[\"+tl.getNextNum()+\"]\"); } } }} Demo2 123456789101112131415161718192021222324252627282930313233/** * Created by Neko on 2017/11/9. */public class ThreadL2 { private Connection conn;//一个非线程安全的变量 public void addTopic1() throws SQLException{ Statement statement = conn.createStatement();//引用非线程安全变量 } //---------------------&gt;使用ThreadLocal这个connection这个非线程安全进行改造 public static ThreadLocal&lt;Connection&gt; connThreadLocal = new ThreadLocal&lt;Connection&gt;(); public static Connection getConnection(){ //如果connThreadLocal没有本线程对应的Connection创建一个新的Connection //并将其保存到线程本地变量中 if(connThreadLocal.get() == null){ Connection conn = getConnection(); connThreadLocal.set(conn); return conn; } else { return connThreadLocal.get();//直接返回本地变量 } } public void addTopic() throws SQLException{ //从Threadlocal中获取线程对应的Connection Statement statement2 = getConnection().createStatement(); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/basic/javabasic-threadlocal/"},{"title":"Java关于时间操作整理","text":"由于最近的项目中，经常需要对时间进行操作和计算，每次搜索出的计算方式都不一样，为了保证代码的统一性，还是仔细的看一下，java的时间和相关处理类，到底都有什么吧。 Date (java.util.date) Date类的大部分方法都被标记为Deprecated过时方法。在java1.8之后，增加了新的时间处理类(java.time)。 1234567891011121314151617181920Date date = new Date();//已被标记为过时date.getMinutes();//替代方法为，详见后文Calendar.get(Calendar.MINUTE);//仍可使用的方法：date.toInstant(); //转换为Instant对象//进行时间的比较date.after(d); //true date在指定时间之后则返回 truedate.before(d);//false date在指定时间之前则返回 truedate.equals(d);//比较两个日期是否相等date.compareTo(d);// 比较当调用此方法的Date对象和指定日期。// 两者相等时候返回0。// 调用对象在指定日期之前则返回负数。// 调用对象在指定日期之后则返回正数。 Time (java.time) Java1.8新增的类，用来扩展Date的功能。 1234567891011121314151617181920212223242526272829//获得当前时间 这个时间是精确到纳秒的Instant instant = Instant.now();//从默认时区的系统时钟获取当前日期LocalDate.now();//从默认时区的系统时钟获取当前时间LocalTime.now();//从默认时区的系统时钟获取当前日期和时间LocalDateTime.now();//从默认时区的系统时钟获取当前的日期时间时差时区ZonedDateTime.now();//将java.util.Date转换为Instant Instant instant = Instant.ofEpochMilli(new Date().getTime()); //从字符串类型中创建Instant类型的时间 instant = Instant.parse(\"1995-10-23T10:12:35Z\");//当前时间加上1小时10分钟Instant instant1 = instant.plus(Duration.ofHours(1).plusMinutes(10));//计算5天前的时间instant.minus(5, ChronoUnit.DAYS); // Option 1 方法1 instant.minus(Duration.ofDays(5)); // Option 2 方法2 //计算两个Instant之间的分钟数 long diffAsMinutes = instant.periodUntil(instant1, ChronoUnit.MINUTES); // 方法1 long diffAsMinutes = ChronoUnit.MINUTES.between(instant, instant1); // 方法2//Instant可以进行比较instant1.isAfter(instant), instant1.isBefore(instant)); Calendar (java.util.Calendar) Calendar可以用来截取时间的各种部分，替代了Date中作废的方法。 Calendar.MONTH 月份是从0开始计算的，所以要记得+1才是真正的月份。 12345678910Calendar c = Calendar.getInstance(); // 获取当前时间的日历对象Calendar c1 = Calendar.getInstance(TimeZone.getTimeZone(\"GMT+08:00\")); //获取东八区的日历实例对象c.getTime(); //返回一个Date类型的时间 Fri Apr 30 04:53:38 UTC 2021c.getTimeInMillis(); //返回当前时间的毫秒数c.getTimeZone().getDisplayName(); //默认区域的用户的时区名称c.getTimeZone().getID(); //Asia/Shanghai 返回时区ID//计算五天前的日期是多少c.add(Calendar.DAY_OF_MONTH, -5); GregorianCalendar是一个计算函数，是 Calendar 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。 通过此函数可以对日期时间进行计算。 12GregorianCalendar calendar = new GregorianCalendar();calendar.isLeapYear(2021); //判断是否为闰年 true 闰年 SimpleDateFormat (java.text.SimpleDateFormat) SimpleDateFormat继承抽象类 DateFormat。 是一个以与语言环境有关的方式来格式化和解析日期的具体类，且非线程安全。 通过它我们可以方便的把时间转换为需要的格式。 字母 描述 表示 示例 y 年份 Year 2018；18 M 月份 Month July; Jul; 07 d 月内的日期 Number 10 h 12小时制(1~12) Number 12 H 24小时制 (0~23) Number 22 m 分钟数 Number 30 s 秒数 Number 55 S 毫秒数 Number 234 E 星期几 Text Tuesday D 年内的天数 Number 180 F 月内的星期 Number 2 (second Wed. in July) w 年内的周数 Number 40 W 月内的周数 Number 1 a AM/PM 标记 Text PM k 24小时制(1~24) Number 24 K 12小时制(0~11) Number 10 z 时区 General time zone Eastern Standard Time PS：表格引用见参考 12345// 假设不加Locale.ENGLISH，默认则以本系统语言(中文)显示Date d = new Date();// 年份，月份，日，星期，小时，分钟，秒全显示(数位不够，则用 0 填充)。SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd a EEEE hh:mm:ss.SSS z \",Locale.ENGLISH);System.out.println(sdf.format(d)); // 2021/05/08 PM Saturday 17:37:50.432 CST 参考 https://blog.csdn.net/weixin_44064134/article/details/107672501 https://www.cnblogs.com/zeo-to-one/p/9357490.html https://www.cnblogs.com/sbj-dawn/p/7439953.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/java-guan-yu-shi-jian-cao-zuo-zheng-li/"},{"title":"使用RedisTemplate操作Redis","text":"使用RedisTemplate操作Redis 补充：List,Set,Map 区别 List,Set都继承自Collection接口，Map不是 List特点：元素有放入顺序，元素可以重复 Set特点：元素无放入顺序，元素不可重复，重复元素会被覆盖。 (元素虽然放入无顺序，但是元素在set中的位置是由该元素的HashCode决定的，其位置其实是固定的) Map特点：适合存储键值对的数据 Redis配置：spring-redis.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- jedis-2.7.2.jar 依赖jar包 commons-pool2-2.3.jar jedis基于 commons-pool2-2.3.jar 自己实现了一个资源池。 配置参数 详见 http://blog.csdn.net/liang_love_java/article/details/50510753 --&gt; &lt;bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;!--maxIdle 最大空闲资源数，默认值 8 （int类型）--&gt; &lt;property name=\"maxIdle\" value=\"1\" /&gt; &lt;!--maxTotal 允许创建资源的最大数量，默认值 8，-1 代表无数量限制（int类型）--&gt; &lt;property name=\"maxTotal\" value=\"5\" /&gt; &lt;!--blockWhenExhausted 默认值 true ，当资源耗尽时，是否阻塞等待获取资源--&gt; &lt;property name=\"blockWhenExhausted\" value=\"true\" /&gt; &lt;!--maxWaitMillis 获取资源时的等待时间，单位毫秒。当 blockWhenExhausted 配置为 true 时， 此值有效。 -1 代表无时间限制，一直阻塞直到有可用的资源。（long类型）--&gt; &lt;property name=\"maxWaitMillis\" value=\"30000\" /&gt; &lt;!--testOnBorrow 默认值 false ，当设置为true时， 每次从池中获取资源时都会调用 factory.validateObject() 方法 --&gt; &lt;property name=\"testOnBorrow\" value=\"true\" /&gt; &lt;/bean&gt; &lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"hostName\" value=\"127.0.0.1\" /&gt; &lt;!--property name=\"hostName\" value=\"10.1.8.200\" /--&gt; &lt;property name=\"port\" value=\"6379\"/&gt; &lt;property name=\"poolConfig\" ref=\"jedisPoolConfig\" /&gt; &lt;property name=\"usePool\" value=\"true\"/&gt; &lt;/bean&gt; &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" /&gt; &lt;property name=\"keySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\" /&gt; &lt;/property&gt; &lt;property name=\"valueSerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\" /&gt; &lt;/property&gt; &lt;property name=\"hashKeySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/&gt; &lt;/property&gt; &lt;property name=\"hashValueSerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Created by Neko on 2017/11/7. */public class Test1 { public static void main(String[] args) { ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"spring-redis.xml\"); final RedisTemplate&lt;String,Object&gt; redisTemplate = ctx.getBean(\"redisTemplate\",RedisTemplate.class); //添加一个key ValueOperations&lt;String,Object&gt; value = redisTemplate.opsForValue(); value.set(\"key1\",\"HELLO!!\"); //获取这个Key的值 System.out.println(value.get(\"key1\")); //添加一个Hash集合 //HashOperations&lt;Key,hashkey,value&gt; //key用来区分是来自哪个HashMap //hashkey是HashMap中的key HashOperations&lt;String,Object,Object&gt; hash = redisTemplate.opsForHash(); Map&lt;String,Object&gt; map1 = new HashMap&lt;String,Object&gt;(); Map&lt;String,Object&gt; map2 = new HashMap&lt;String,Object&gt;(); map1.put(\"name\",\"Apple\"); map1.put(\"age\",\"40\"); map2.put(\"name\",\"Orange\"); map2.put(\"age\",\"60\"); hash.putAll(\"map1\",map1); hash.putAll(\"map2\",map2); //获取map System.out.println(\"MAP1: \"+hash.entries(\"map1\")); System.out.println(\"MAP2: \"+hash.entries(\"map2\")); //添加一个list列表 ListOperations&lt;String,Object&gt; list = redisTemplate.opsForList(); list.rightPush(\"oplist1\",\"1st\"); list.rightPush(\"oplist1\",\"2nd\"); list.rightPush(\"oplist1\",\"3rd\"); //输出list System.out.println(list.range(\"oplist1\",0,2)); list.leftPush(\"oplist2\",\"1st\"); list.leftPush(\"oplist2\",\"2nd\"); list.leftPush(\"oplist2\",\"3rd\"); System.out.println(list.range(\"oplist2\",0,2)); list.rightPush(\"oplist3\",\"1st\"); list.rightPush(\"oplist3\",\"2nd\"); list.rightPush(\"oplist3\",\"3rd\"); System.out.println(list.range(\"oplist3\",0,2)); list.leftPush(\"oplist3\",\"1st\"); list.leftPush(\"oplist3\",\"2nd\"); list.leftPush(\"oplist3\",\"3rd\"); System.out.println(list.range(\"oplist3\",0,5)); //添加一个set集合 SetOperations&lt;String,Object&gt; set = redisTemplate.opsForSet(); set.add(\"opSet\",\"Apple\"); set.add(\"opSet\",\"13\"); set.add(\"opSet\",\"13\");//由于是集合，相同的元素会覆盖掉 //输出set集合 System.out.println(set.members(\"opSet\")); //添加有序的set集合 ZSetOperations&lt;String,Object&gt; zset = redisTemplate.opsForZSet(); zset.add(\"opZset\",\"Apple\",2); zset.add(\"opZset\",\"Orange\",0); zset.add(\"opZset\",\"Banana\",1); //输出有序set集合 System.out.println(zset.rangeByScore(\"opZset\",0,2)); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/javaweb/shi-yong-redistemplate-cao-zuo-redis/"},{"title":"使用swagger自动生成html文档","text":"使用swagger自动生成html文档 使用方法 1234567891011121314--启动类添加注解--@EnableSwagger2--添加依赖--&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 启动后访问地址 http://localhost:8060/swagger-ui.html swagger 常用注解 @ApiOperation(value = \"用户查询服务\") 标记方法名 123@ApiOperation(value = \"用户查询服务\")public List&lt;User&gt; query(@RequestParam String username){} @ApiModelProperty(value = \"年龄\") 标记在元素上，表名该元素作用 12@ApiModelProperty(value = \"年龄\")private int age; @ApiParam(\"用户id\") 标记在方法的请求参数上 1public User getInfo(@ApiParam(\"用户id\") @PathVariable String id) {} SpringBoot集成Swagger2中遇到的问题 Spring Boot自动配置本身不会自动把/swagger-ui.html这个路径映射到对应的目录META-INF/resources/下面。我们加上这个映射即可。代码如下： 1234567891011@Configurationclass WebMvcConfig extends WebMvcConfigurerAdapter { @Override void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"swagger-ui.html\") .addResourceLocations(\"classpath:/META-INF/resources/\") registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") }} 同时，在启动类上添加注解@EnableWebMvc。 当然，为了更加方便使用SpringBoot集成swagger，这个工作可以直接通过定制swagger-starter来完成。 使用WireMock快速伪造RESTful服务 使用方法 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.github.tomakehurst&lt;/groupId&gt; &lt;artifactId&gt;wiremock&lt;/artifactId&gt;&lt;/dependency&gt; 下载jar运行 1http://wiremock.org/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/javaweb/shi-yong-swagger-zi-dong-sheng-cheng-html-wen-dang/"},{"title":"记一次生产环境上线的经历","text":"最近写了一个项目，也是两三年没写后端的我再次尝试后端项目，在开发和部署的过程中，都遇到了许多奇奇怪怪的问题， 记录下来，也算是对这段时间惊心动魄经历的一次总结吧。 K8s容器内部时间错误 项目上线后，是使用Docker+K8s进行运维和部署的，但是测试环境是普通ECS主机。测试环境一切正常， 但是在生产环境出现了订单时间出现了错误，起初是认为自己项目时间没有做\"UTC+8\"处理，或者是mysql连接时 未指定时区。不过这两点检查之后，都没有问题。最后把目光放到了容器里。 在测试机使用命令date出现的时间是这样的： 1Fri Apr 30 04:53:38 UTC 2021 但是在K8s那边检查时间，出来的时间是： 1Fri Apr 30 04:53:38 EDT 2021 如果容器的时间出现问题，那么就很好解释为什么存到数据库里的时间出现问题了。因为运维的同学不在国内，所以他的时区也不是UTC+8，就没有发现这个问题。 时间调整好后，问题消失。 最后补充一下常见的几个时区吧： GMT，即格林尼治标准时间，也就是世界时。 UTC，即协调世界时。现在用的最多的也是UTC。 CST，中国标准时间（China Standard Time） GMT + 8 = UTC + 8 = CST 提示：前提系统的区域设置为Asia/Shanghai，CST还有其他释义，是与区域有关。 EDT，美国东部夏令时间,波士顿、纽约市、华盛顿哥伦比亚特区,都在这个时区内,跟北京时间有12小时的时差,晚12小时。 关联问题： 由于容器时间错误，所以导致微信支付SDK SSL异常，报错401。如果有集成微信支付项目启动时报错401，就需要检查下系统时间和时区是否正确了。 ApplicationRunner里面不允许执行死循环操作，需要独立线程 由于使用Redis的Zset来做订单超时队列（轻量实现），在启动项目的时候，需要启动一个死循环线程来执行zRangeWithScores() 但是发现不是所有继承ApplicationRunner的类都会被启动，这是什么原因呢，难道是没有指定顺序么？ 经查阅，找到了控制顺序的注解@Order(1)里面的数字则为具体启动的顺序。示例代码如下： 1234567891011@Component@Order(3)public class ApplicationRunnerImpl implements ApplicationRunner { Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void run(ApplicationArguments args) throws Exception { logger.info(\"====== Service All Init Complete ======\"); }} 经过调整将死循环任务放在最后一个执行可以解决此问题，但是治标不治本，查看下源码实现可以看到： 他是通过foreach遍历每一个实现ApplicationRunner的类，执行每一个类的内容来实现的，那么不可以在ApplicationRunner里面出现死循环就很好理解了，我们创建一个线程就可以解决此问题了。 1234567891011121314151617181920//SpringApplication.classprivate void callRunners(ApplicationContext context, ApplicationArguments args) { List&lt;Object&gt; runners = new ArrayList(); runners.addAll(context.getBeansOfType(ApplicationRunner.class).values()); runners.addAll(context.getBeansOfType(CommandLineRunner.class).values()); AnnotationAwareOrderComparator.sort(runners); Iterator var4 = (new LinkedHashSet(runners)).iterator(); while(var4.hasNext()) { Object runner = var4.next(); if (runner instanceof ApplicationRunner) { this.callRunner((ApplicationRunner)runner, args); } if (runner instanceof CommandLineRunner) { this.callRunner((CommandLineRunner)runner, args); } }} Maven镜像源地址可以配阿里的 由于K8s每次构建镜像速度都是纯净环境从零构建的，每次都需要重新拉取一遍依赖，但是由于网速限制，拉取占用了太多时间。 于是将镜像源配置为阿里的源，这样使用阿里的K8s服务时，构建速度会快很多。 1234567891011121314&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;maven-ali&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; JSON变成了XML 由于微信的SDK接入比较复杂，所以使用了一个简单的库来解决这个问题payment-spring-boot-starter但是引入之后，返回的内容都默认变成了XML格式。 经过排查，是由于这个库引入了jackson-dataformat-xml导致的，那么我们直接移除它就可以了。 1234567891011&lt;dependency&gt; &lt;groupId&gt;cn.felord&lt;/groupId&gt; &lt;artifactId&gt;payment-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0.8.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/java/javaweb/ji-yi-ci-sheng-chan-huan-jing-shang-xian-de-jing-li/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Frontend","slug":"Frontend","link":"/tags/Frontend/"},{"name":"HTML5","slug":"HTML5","link":"/tags/HTML5/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"},{"name":"ThreadLocal","slug":"ThreadLocal","link":"/tags/ThreadLocal/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"}],"categories":[{"name":"Android","slug":"android","link":"/categories/android/"},{"name":"日常","slug":"daily","link":"/categories/daily/"},{"name":"Frontend","slug":"frontend","link":"/categories/frontend/"},{"name":"Javascript","slug":"frontend/javascript","link":"/categories/frontend/javascript/"},{"name":"Other","slug":"other","link":"/categories/other/"},{"name":"Css","slug":"frontend/css","link":"/categories/frontend/css/"},{"name":"Java","slug":"java","link":"/categories/java/"},{"name":"Basic","slug":"java/basic","link":"/categories/java/basic/"},{"name":"Algorithm","slug":"java/algorithm","link":"/categories/java/algorithm/"},{"name":"JavaWeb","slug":"java/javaweb","link":"/categories/java/javaweb/"}]}